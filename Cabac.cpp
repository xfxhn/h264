#include "Cabac.h"
#include "ParseSlice.h"

Cabac::Cabac()
{
	codIRange = 0;
	codIOffset = 0;

	memset(stateIdx, 0, sizeof(int32_t) * 1024);
	memset(MPSValue, 0, sizeof(int32_t) * 1024);
}

Cabac::~Cabac()
{
}

void Cabac::getMN(const int ctxIdx, const SLIECETYPE slice_type, const int cabac_init_idc, int& m, int& n)
{
	if (ctxIdx >= 0 && ctxIdx <= 10)
	{
		constexpr int8_t mn[11][2] =
		{
			{20, -15}, {2, 54}, {3, 74}, {20, -15}, {2, 54}, {3, 74}, {-28, 127}, {-23, 104}, {-6, 53}, {-1, 54},
			{7, 51}
		};

		m = mn[ctxIdx][0];
		n = mn[ctxIdx][1];
	}
	else if (ctxIdx >= 11 && ctxIdx <= 23)
	{
		const int8_t mn[3][13][2] =
		{
			{
				{23, 33}, {23, 2}, {21, 0}, {1, 9}, {0, 49}, {-37, 118}, {5, 57}, {-13, 78}, {-11, 65}, {1, 62},
				{12, 49}, {-4, 73}, {17, 50}
			},
			{
				{22, 25}, {34, 0}, {16, 0}, {-2, 9}, {4, 41}, {-29, 118}, {2, 65}, {-6, 71}, {-13, 79}, {5, 52},
				{9, 50}, {-3, 70}, {10, 54}
			},
			{
				{29, 16}, {25, 0}, {14, 0}, {-10, 51}, {-3, 62}, {-27, 99}, {26, 16}, {-4, 85}, {-24, 102}, {5, 57},
				{6, 57}, {-17, 73}, {14, 57}
			}
		};

		m = mn[cabac_init_idc][ctxIdx - 11][0];
		n = mn[cabac_init_idc][ctxIdx - 11][1];
	}
	else if (ctxIdx >= 24 && ctxIdx <= 39)
	{
		const int8_t mn[3][16][2] =
		{
			{
				{18, 64}, {9, 43}, {29, 0}, {26, 67}, {16, 90}, {9, 104}, {-46, 127}, {-20, 104}, {1, 67}, {-13, 78},
				{-11, 65}, {1, 62}, {-6, 86}, {-17, 95}, {-6, 61}, {9, 45}
			},
			{
				{26, 34}, {19, 22}, {40, 0}, {57, 2}, {41, 36}, {26, 69}, {-45, 127}, {-15, 101}, {-4, 76}, {-6, 71},
				{-13, 79}, {5, 52}, {6, 69}, {-13, 90}, {0, 52}, {8, 43}
			},
			{
				{20, 40}, {20, 10}, {29, 0}, {54, 0}, {37, 42}, {12, 97}, {-32, 127}, {-22, 117}, {-2, 74}, {-4, 85},
				{-24, 102}, {5, 57}, {-6, 93}, {-14, 88}, {-6, 44}, {4, 55}
			}
		};

		m = mn[cabac_init_idc][ctxIdx - 24][0];
		n = mn[cabac_init_idc][ctxIdx - 24][1];
	}
	else if (ctxIdx >= 40 && ctxIdx <= 53)
	{
		const int8_t mn[3][14][2] =
		{
			{
				{-3, 69}, {-6, 81}, {-11, 96}, {6, 55}, {7, 67}, {-5, 86}, {2, 88}, {0, 58}, {-3, 76}, {-10, 94},
				{5, 54}, {4, 69}, {-3, 81}, {0, 88}
			},
			{
				{-2, 69}, {-5, 82}, {-10, 96}, {2, 59}, {2, 75}, {-3, 87}, {-3, 100}, {1, 56}, {-3, 74}, {-6, 85},
				{0, 59}, {-3, 81}, {-7, 86}, {-5, 95}
			},
			{
				{-11, 89}, {-15, 103}, {-21, 116}, {19, 57}, {20, 58}, {4, 84}, {6, 96}, {1, 63}, {-5, 85}, {-13, 106},
				{5, 63}, {6, 75}, {-3, 90}, {-1, 101}
			}
		};

		m = mn[cabac_init_idc][ctxIdx - 40][0];
		n = mn[cabac_init_idc][ctxIdx - 40][1];
	}
	else if (ctxIdx >= 54 && ctxIdx <= 59)
	{
		const int8_t mn[3][6][2] =
		{
			{
				{-7, 67}, {-5, 74}, {-4, 74}, {-5, 80}, {-7, 72}, {1, 58}
			},
			{
				{-1, 66}, {-1, 77}, {1, 70}, {-2, 86}, {-5, 72}, {0, 61}
			},
			{
				{3, 55}, {-4, 79}, {-2, 75}, {-12, 97}, {-7, 50}, {1, 60}
			}
		};

		m = mn[cabac_init_idc][ctxIdx - 54][0];
		n = mn[cabac_init_idc][ctxIdx - 54][1];
	}
	else if (ctxIdx >= 399 && ctxIdx <= 401)
	{
		const int8_t mn[4][3][2] =
		{
			{
				{31, 21}, {31, 31}, {25, 50}
			},
			{
				{12, 40}, {11, 51}, {14, 59}
			},
			{
				{25, 32}, {21, 49}, {21, 54}
			},
			{
				{21, 33}, {19, 50}, {17, 61}
			}
		};

		if (slice_type == SLIECETYPE::H264_SLIECE_TYPE_I)
		{
			m = mn[0][ctxIdx - 399][0];
			n = mn[0][ctxIdx - 399][1];
		}
		else
		{
			m = mn[cabac_init_idc + 1][ctxIdx - 399][0];
			n = mn[cabac_init_idc + 1][ctxIdx - 399][1];
		}
	}
	else if (ctxIdx >= 60 && ctxIdx <= 69)
	{
		const int8_t mn[10][2] =
		{
			{0, 41}, {0, 63}, {0, 63}, {0, 63}, {-9, 83}, {4, 86}, {0, 97}, {-7, 72}, {13, 41}, {3, 62}
		};

		m = mn[ctxIdx - 60][0];
		n = mn[ctxIdx - 60][1];
	}
	else if (ctxIdx >= 70 && ctxIdx <= 104)
	{
		const int8_t mn[4][35][2] =
		{
			{
				{0, 11}, {1, 55}, {0, 69}, {-17, 127}, {-13, 102}, {0, 82}, {-7, 74}, {-21, 107}, {-27, 127}, {-31, 127},
				{-24, 127}, {-18, 95}, {-27, 127}, {-21, 114}, {-30, 127}, {-17, 123}, {-12, 115}, {-16, 122}, {-11, 115}, {-12, 63},
				{-2, 68}, {-15, 84}, {-13, 104}, {-3, 70}, {-8, 93}, {-10, 90}, {-30, 127}, {-1, 74}, {-6, 97}, {-7, 91},
				{-20, 127}, {-4, 56}, {-5, 82}, {-7, 76}, {-22, 125}
			},
			{
				{0, 45}, {-4, 78}, {-3, 96}, {-27, 126}, {-28, 98}, {-25, 101}, {-23, 67}, {-28, 82}, {-20, 94}, {-16, 83},
				{-22, 110}, {-21, 91}, {-18, 102}, {-13, 93}, {-29, 127}, {-7, 92}, {-5, 89}, {-7, 96}, {-13, 108}, {-3, 46},
				{-1, 65}, {-1, 57}, {-9, 93}, {-3, 74}, {-9, 92}, {-8, 87}, {-23, 126}, {5, 54}, {6, 60}, {6, 59},
				{6, 69}, {-1, 48}, {0, 68}, {-4, 69}, {-8, 88}
			},
			{
				{13, 15}, {7, 51}, {2, 80}, {-39, 127}, {-18, 91}, {-17, 96}, {-26, 81}, {-35, 98}, {-24, 102}, {-23, 97},
				{-27, 119}, {-24, 99}, {-21, 110}, {-18, 102}, {-36, 127}, {0, 80}, {-5, 89}, {-7, 94}, {-4, 92}, {0, 39},
				{0, 65}, {-15, 84}, {-35, 127}, {-2, 73}, {-12, 104}, {-9, 91}, {-31, 127}, {3, 55}, {7, 56}, {7, 55},
				{8, 61}, {-3, 53}, {0, 68}, {-7, 74}, {-9, 88}
			},
			{
				{7, 34}, {-9, 88}, {-20, 127}, {-36, 127}, {-17, 91}, {-14, 95}, {-25, 84}, {-25, 86}, {-12, 89}, {-17, 91},
				{-31, 127}, {-14, 76}, {-18, 103}, {-13, 90}, {-37, 127}, {11, 80}, {5, 76}, {2, 84}, {5, 78}, {-6, 55},
				{4, 61}, {-14, 83}, {-37, 127}, {-5, 79}, {-11, 104}, {-11, 91}, {-30, 127}, {0, 65}, {-2, 79}, {0, 72},
				{-4, 92}, {-6, 56}, {3, 68}, {-8, 71}, {-13, 98}
			}
		};

		if (slice_type == SLIECETYPE::H264_SLIECE_TYPE_I || slice_type == SLIECETYPE::H264_SLIECE_TYPE_SI)
		{
			m = mn[0][ctxIdx - 70][0];
			n = mn[0][ctxIdx - 70][1];
		}
		else
		{
			m = mn[cabac_init_idc + 1][ctxIdx - 70][0];
			n = mn[cabac_init_idc + 1][ctxIdx - 70][1];
		}
	}
	else if (ctxIdx >= 105 && ctxIdx <= 165)
	{
		const int8_t mn[4][61][2] =
		{
			{
				{-7, 93}, {-11, 87}, {-3, 77}, {-5, 71}, {-4, 63}, {-4, 68}, {-12, 84}, {-7, 62}, {-7, 65}, {8, 61},
				{5, 56}, {-2, 66}, {1, 64}, {0, 61}, {-2, 78}, {1, 50}, {7, 52}, {10, 35}, {0, 44}, {11, 38},
				{1, 45}, {0, 46}, {5, 44}, {31, 17}, {1, 51}, {7, 50}, {28, 19}, {16, 33}, {14, 62}, {-13, 108},
				{-15, 100}, {-13, 101}, {-13, 91}, {-12, 94}, {-10, 88}, {-16, 84}, {-10, 86}, {-7, 83}, {-13, 87}, {-19, 94},
				{1, 70}, {0, 72}, {-5, 74}, {18, 59}, {-8, 102}, {-15, 100}, {0, 95}, {-4, 75}, {2, 72}, {-11, 75},
				{-3, 71}, {15, 46}, {-13, 69}, {0, 62}, {0, 65}, {21, 37}, {-15, 72}, {9, 57}, {16, 54}, {0, 62},
				{12, 72}
			},
			{
				{-2, 85}, {-6, 78}, {-1, 75}, {-7, 77}, {2, 54}, {5, 50}, {-3, 68}, {1, 50}, {6, 42}, {-4, 81},
				{1, 63}, {-4, 70}, {0, 67}, {2, 57}, {-2, 76}, {11, 35}, {4, 64}, {1, 61}, {11, 35}, {18, 25},
				{12, 24}, {13, 29}, {13, 36}, {-10, 93}, {-7, 73}, {-2, 73}, {13, 46}, {9, 49}, {-7, 100}, {9, 53},
				{2, 53}, {5, 53}, {-2, 61}, {0, 56}, {0, 56}, {-13, 63}, {-5, 60}, {-1, 62}, {4, 57}, {-6, 69},
				{4, 57}, {14, 39}, {4, 51}, {13, 68}, {3, 64}, {1, 61}, {9, 63}, {7, 50}, {16, 39}, {5, 44},
				{4, 52}, {11, 48}, {-5, 60}, {-1, 59}, {0, 59}, {22, 33}, {5, 44}, {14, 43}, {-1, 78}, {0, 60},
				{9, 69}
			},
			{
				{-13, 103}, {-13, 91}, {-9, 89}, {-14, 92}, {-8, 76}, {-12, 87}, {-23, 110}, {-24, 105}, {-10, 78}, {-20, 112},
				{-17, 99}, {-78, 127}, {-70, 127}, {-50, 127}, {-46, 127}, {-4, 66}, {-5, 78}, {-4, 71}, {-8, 72}, {2, 59},
				{-1, 55}, {-7, 70}, {-6, 75}, {-8, 89}, {-34, 119}, {-3, 75}, {32, 20}, {30, 22}, {-44, 127}, {0, 54},
				{-5, 61}, {0, 58}, {-1, 60}, {-3, 61}, {-8, 67}, {-25, 84}, {-14, 74}, {-5, 65}, {5, 52}, {2, 57},
				{0, 61}, {-9, 69}, {-11, 70}, {18, 55}, {-4, 71}, {0, 58}, {7, 61}, {9, 41}, {18, 25}, {9, 32},
				{5, 43}, {9, 47}, {0, 44}, {0, 51}, {2, 46}, {19, 38}, {-4, 66}, {15, 38}, {12, 42}, {9, 34},
				{0, 89}
			},
			{
				{-4, 86}, {-12, 88}, {-5, 82}, {-3, 72}, {-4, 67}, {-8, 72}, {-16, 89}, {-9, 69}, {-1, 59}, {5, 66},
				{4, 57}, {-4, 71}, {-2, 71}, {2, 58}, {-1, 74}, {-4, 44}, {-1, 69}, {0, 62}, {-7, 51}, {-4, 47},
				{-6, 42}, {-3, 41}, {-6, 53}, {8, 76}, {-9, 78}, {-11, 83}, {9, 52}, {0, 67}, {-5, 90}, {1, 67},
				{-15, 72}, {-5, 75}, {-8, 80}, {-21, 83}, {-21, 64}, {-13, 31}, {-25, 64}, {-29, 94}, {9, 75}, {17, 63},
				{-8, 74}, {-5, 35}, {-2, 27}, {13, 91}, {3, 65}, {-7, 69}, {8, 77}, {-10, 66}, {3, 62}, {-3, 68},
				{-20, 81}, {0, 30}, {1, 7}, {-3, 23}, {-21, 74}, {16, 66}, {-23, 124}, {17, 37}, {44, -18}, {50, -34},
				{-22, 127}
			}
		};

		if (slice_type == SLIECETYPE::H264_SLIECE_TYPE_I || slice_type == SLIECETYPE::H264_SLIECE_TYPE_SI)
		{
			m = mn[0][ctxIdx - 105][0];
			n = mn[0][ctxIdx - 105][1];
		}
		else
		{
			m = mn[cabac_init_idc + 1][ctxIdx - 105][0];
			n = mn[cabac_init_idc + 1][ctxIdx - 105][1];
		}
	}
	else if (ctxIdx >= 166 && ctxIdx <= 226)
	{
		const int8_t mn[4][61][2] =
		{
			{
				{24, 0}, {15, 9}, {8, 25}, {13, 18}, {15, 9}, {13, 19}, {10, 37}, {12, 18}, {6, 29}, {20, 33},
				{15, 30}, {4, 45}, {1, 58}, {0, 62}, {7, 61}, {12, 38}, {11, 45}, {15, 39}, {11, 42}, {13, 44},
				{16, 45}, {12, 41}, {10, 49}, {30, 34}, {18, 42}, {10, 55}, {17, 51}, {17, 46}, {0, 89}, {26, -19},
				{22, -17}, {26, -17}, {30, -25}, {28, -20}, {33, -23}, {37, -27}, {33, -23}, {40, -28}, {38, -17}, {33, -11},
				{40, -15}, {41, -6}, {38, 1}, {41, 17}, {30, -6}, {27, 3}, {26, 22}, {37, -16}, {35, -4}, {38, -8},
				{38, -3}, {37, 3}, {38, 5}, {42, 0}, {35, 16}, {39, 22}, {14, 48}, {27, 37}, {21, 60}, {12, 68},
				{2, 97}
			},
			{
				{11, 28}, {2, 40}, {3, 44}, {0, 49}, {0, 46}, {2, 44}, {2, 51}, {0, 47}, {4, 39}, {2, 62},
				{6, 46}, {0, 54}, {3, 54}, {2, 58}, {4, 63}, {6, 51}, {6, 57}, {7, 53}, {6, 52}, {6, 55},
				{11, 45}, {14, 36}, {8, 53}, {-1, 82}, {7, 55}, {-3, 78}, {15, 46}, {22, 31}, {-1, 84}, {25, 7},
				{30, -7}, {28, 3}, {28, 4}, {32, 0}, {34, -1}, {30, 6}, {30, 6}, {32, 9}, {31, 19}, {26, 27},
				{26, 30}, {37, 20}, {28, 34}, {17, 70}, {1, 67}, {5, 59}, {9, 67}, {16, 30}, {18, 32}, {18, 35},
				{22, 29}, {24, 31}, {23, 38}, {18, 43}, {20, 41}, {11, 63}, {9, 59}, {9, 64}, {-1, 94}, {-2, 89},
				{-9, 108}
			},
			{
				{4, 45}, {10, 28}, {10, 31}, {33, -11}, {52, -43}, {18, 15}, {28, 0}, {35, -22}, {38, -25}, {34, 0},
				{39, -18}, {32, -12}, {102, -94}, {0, 0}, {56, -15}, {33, -4}, {29, 10}, {37, -5}, {51, -29}, {39, -9},
				{52, -34}, {69, -58}, {67, -63}, {44, -5}, {32, 7}, {55, -29}, {32, 1}, {0, 0}, {27, 36}, {33, -25},
				{34, -30}, {36, -28}, {38, -28}, {38, -27}, {34, -18}, {35, -16}, {34, -14}, {32, -8}, {37, -6}, {35, 0},
				{30, 10}, {28, 18}, {26, 25}, {29, 41}, {0, 75}, {2, 72}, {8, 77}, {14, 35}, {18, 31}, {17, 35},
				{21, 30}, {17, 45}, {20, 42}, {18, 45}, {27, 26}, {16, 54}, {7, 66}, {16, 56}, {11, 73}, {10, 67},
				{-10, 116}
			},
			{
				{4, 39}, {0, 42}, {7, 34}, {11, 29}, {8, 31}, {6, 37}, {7, 42}, {3, 40}, {8, 33}, {13, 43},
				{13, 36}, {4, 47}, {3, 55}, {2, 58}, {6, 60}, {8, 44}, {11, 44}, {14, 42}, {7, 48}, {4, 56},
				{4, 52}, {13, 37}, {9, 49}, {19, 58}, {10, 48}, {12, 45}, {0, 69}, {20, 33}, {8, 63}, {35, -18},
				{33, -25}, {28, -3}, {24, 10}, {27, 0}, {34, -14}, {52, -44}, {39, -24}, {19, 17}, {31, 25}, {36, 29},
				{24, 33}, {34, 15}, {30, 20}, {22, 73}, {20, 34}, {19, 31}, {27, 44}, {19, 16}, {15, 36}, {15, 36},
				{21, 28}, {25, 21}, {30, 20}, {31, 12}, {27, 16}, {24, 42}, {0, 93}, {14, 56}, {15, 57}, {26, 38},
				{-24, 127}
			}
		};

		if (slice_type == SLIECETYPE::H264_SLIECE_TYPE_I || slice_type == SLIECETYPE::H264_SLIECE_TYPE_SI)
		{
			m = mn[0][ctxIdx - 166][0];
			n = mn[0][ctxIdx - 166][1];
		}
		else
		{
			m = mn[cabac_init_idc + 1][ctxIdx - 166][0];
			n = mn[cabac_init_idc + 1][ctxIdx - 166][1];
		}
	}
	else if (ctxIdx >= 227 && ctxIdx <= 275)
	{
		const int8_t mn[4][49][2] =
		{
			{
				{-3, 71}, {-6, 42}, {-5, 50}, {-3, 54}, {-2, 62}, {0, 58}, {1, 63}, {-2, 72}, {-1, 74}, {-9, 91},
				{-5, 67}, {-5, 27}, {-3, 39}, {-2, 44}, {0, 46}, {-16, 64}, {-8, 68}, {-10, 78}, {-6, 77}, {-10, 86},
				{-12, 92}, {-15, 55}, {-10, 60}, {-6, 62}, {-4, 65}, {-12, 73}, {-8, 76}, {-7, 80}, {-9, 88}, {-17, 110},
				{-11, 97}, {-20, 84}, {-11, 79}, {-6, 73}, {-4, 74}, {-13, 86}, {-13, 96}, {-11, 97}, {-19, 117}, {-8, 78},
				{-5, 33}, {-4, 48}, {-2, 53}, {-3, 62}, {-13, 71}, {-10, 79}, {-12, 86}, {-13, 90}, {-14, 97}
			},
			{
				{-6, 76}, {-2, 44}, {0, 45}, {0, 52}, {-3, 64}, {-2, 59}, {-4, 70}, {-4, 75}, {-8, 82}, {-17, 102},
				{-9, 77}, {3, 24}, {0, 42}, {0, 48}, {0, 55}, {-6, 59}, {-7, 71}, {-12, 83}, {-11, 87}, {-30, 119},
				{1, 58}, {-3, 29}, {-1, 36}, {1, 38}, {2, 43}, {-6, 55}, {0, 58}, {0, 64}, {-3, 74}, {-10, 90},
				{0, 70}, {-4, 29}, {5, 31}, {7, 42}, {1, 59}, {-2, 58}, {-3, 72}, {-3, 81}, {-11, 97}, {0, 58},
				{8, 5}, {10, 14}, {14, 18}, {13, 27}, {2, 40}, {0, 58}, {-3, 70}, {-6, 79}, {-8, 85}
			},
			{
				{-23, 112}, {-15, 71}, {-7, 61}, {0, 53}, {-5, 66}, {-11, 77}, {-9, 80}, {-9, 84}, {-10, 87}, {-34, 127},
				{-21, 101}, {-3, 39}, {-5, 53}, {-7, 61}, {-11, 75}, {-15, 77}, {-17, 91}, {-25, 107}, {-25, 111}, {-28, 122},
				{-11, 76}, {-10, 44}, {-10, 52}, {-10, 57}, {-9, 58}, {-16, 72}, {-7, 69}, {-4, 69}, {-5, 74}, {-9, 86},
				{2, 66}, {-9, 34}, {1, 32}, {11, 31}, {5, 52}, {-2, 55}, {-2, 67}, {0, 73}, {-8, 89}, {3, 52},
				{7, 4}, {10, 8}, {17, 8}, {16, 19}, {3, 37}, {-1, 61}, {-5, 73}, {-1, 70}, {-4, 78}
			},
			{
				{-24, 115}, {-22, 82}, {-9, 62}, {0, 53}, {0, 59}, {-14, 85}, {-13, 89}, {-13, 94}, {-11, 92}, {-29, 127},
				{-21, 100}, {-14, 57}, {-12, 67}, {-11, 71}, {-10, 77}, {-21, 85}, {-16, 88}, {-23, 104}, {-15, 98}, {-37, 127},
				{-10, 82}, {-8, 48}, {-8, 61}, {-8, 66}, {-7, 70}, {-14, 75}, {-10, 79}, {-9, 83}, {-12, 92}, {-18, 108},
				{-4, 79}, {-22, 69}, {-16, 75}, {-2, 58}, {1, 58}, {-13, 78}, {-9, 83}, {-4, 81}, {-13, 99}, {-13, 81},
				{-6, 38}, {-13, 62}, {-6, 58}, {-2, 59}, {-16, 73}, {-10, 76}, {-13, 86}, {-9, 83}, {-10, 87}
			}
		};

		if (slice_type == SLIECETYPE::H264_SLIECE_TYPE_I || slice_type == SLIECETYPE::H264_SLIECE_TYPE_SI)
		{
			m = mn[0][ctxIdx - 227][0];
			n = mn[0][ctxIdx - 227][1];
		}
		else
		{
			m = mn[cabac_init_idc + 1][ctxIdx - 227][0];
			n = mn[cabac_init_idc + 1][ctxIdx - 227][1];
		}
	}
	else if (ctxIdx >= 277 && ctxIdx <= 337)
	{
		const int8_t mn[4][61][2] =
		{
			{
				{-6, 93}, {-6, 84}, {-8, 79}, {0, 66}, {-1, 71}, {0, 62}, {-2, 60}, {-2, 59}, {-5, 75}, {-3, 62},
				{-4, 58}, {-9, 66}, {-1, 79}, {0, 71}, {3, 68}, {10, 44}, {-7, 62}, {15, 36}, {14, 40}, {16, 27},
				{12, 29}, {1, 44}, {20, 36}, {18, 32}, {5, 42}, {1, 48}, {10, 62}, {17, 46}, {9, 64}, {-12, 104},
				{-11, 97}, {-16, 96}, {-7, 88}, {-8, 85}, {-7, 85}, {-9, 85}, {-13, 88}, {4, 66}, {-3, 77}, {-3, 76},
				{-6, 76}, {10, 58}, {-1, 76}, {-1, 83}, {-7, 99}, {-14, 95}, {2, 95}, {0, 76}, {-5, 74}, {0, 70},
				{-11, 75}, {1, 68}, {0, 65}, {-14, 73}, {3, 62}, {4, 62}, {-1, 68}, {-13, 75}, {11, 55}, {5, 64},
				{12, 70}
			},
			{
				{-13, 106}, {-16, 106}, {-10, 87}, {-21, 114}, {-18, 110}, {-14, 98}, {-22, 110}, {-21, 106}, {-18, 103}, {-21, 107},
				{-23, 108}, {-26, 112}, {-10, 96}, {-12, 95}, {-5, 91}, {-9, 93}, {-22, 94}, {-5, 86}, {9, 67}, {-4, 80},
				{-10, 85}, {-1, 70}, {7, 60}, {9, 58}, {5, 61}, {12, 50}, {15, 50}, {18, 49}, {17, 54}, {10, 41},
				{7, 46}, {-1, 51}, {7, 49}, {8, 52}, {9, 41}, {6, 47}, {2, 55}, {13, 41}, {10, 44}, {6, 50},
				{5, 53}, {13, 49}, {4, 63}, {6, 64}, {-2, 69}, {-2, 59}, {6, 70}, {10, 44}, {9, 31}, {12, 43},
				{3, 53}, {14, 34}, {10, 38}, {-3, 52}, {13, 40}, {17, 32}, {7, 44}, {7, 38}, {13, 50}, {10, 57},
				{26, 43}
			},
			{
				{-21, 126}, {-23, 124}, {-20, 110}, {-26, 126}, {-25, 124}, {-17, 105}, {-27, 121}, {-27, 117}, {-17, 102}, {-26, 117},
				{-27, 116}, {-33, 122}, {-10, 95}, {-14, 100}, {-8, 95}, {-17, 111}, {-28, 114}, {-6, 89}, {-2, 80}, {-4, 82},
				{-9, 85}, {-8, 81}, {-1, 72}, {5, 64}, {1, 67}, {9, 56}, {0, 69}, {1, 69}, {7, 69}, {-7, 69},
				{-6, 67}, {-16, 77}, {-2, 64}, {2, 61}, {-6, 67}, {-3, 64}, {2, 57}, {-3, 65}, {-3, 66}, {0, 62},
				{9, 51}, {-1, 66}, {-2, 71}, {-2, 75}, {-1, 70}, {-9, 72}, {14, 60}, {16, 37}, {0, 47}, {18, 35},
				{11, 37}, {12, 41}, {10, 41}, {2, 48}, {12, 41}, {13, 41}, {0, 59}, {3, 50}, {19, 40}, {3, 66},
				{18, 50}
			},
			{
				{-22, 127}, {-25, 127}, {-25, 120}, {-27, 127}, {-19, 114}, {-23, 117}, {-25, 118}, {-26, 117}, {-24, 113}, {-28, 118},
				{-31, 120}, {-37, 124}, {-10, 94}, {-15, 102}, {-10, 99}, {-13, 106}, {-50, 127}, {-5, 92}, {17, 57}, {-5, 86},
				{-13, 94}, {-12, 91}, {-2, 77}, {0, 71}, {-1, 73}, {4, 64}, {-7, 81}, {5, 64}, {15, 57}, {1, 67},
				{0, 68}, {-10, 67}, {1, 68}, {0, 77}, {2, 64}, {0, 68}, {-5, 78}, {7, 55}, {5, 59}, {2, 65},
				{14, 54}, {15, 44}, {5, 60}, {2, 70}, {-2, 76}, {-18, 86}, {12, 70}, {5, 64}, {-12, 70}, {11, 55},
				{5, 56}, {0, 69}, {2, 65}, {-6, 74}, {5, 54}, {7, 54}, {-6, 76}, {-11, 82}, {-2, 77}, {-2, 77},
				{25, 42}
			}
		};

		if (slice_type == SLIECETYPE::H264_SLIECE_TYPE_I || slice_type == SLIECETYPE::H264_SLIECE_TYPE_SI)
		{
			m = mn[0][ctxIdx - 277][0];
			n = mn[0][ctxIdx - 277][1];
		}
		else
		{
			m = mn[cabac_init_idc + 1][ctxIdx - 277][0];
			n = mn[cabac_init_idc + 1][ctxIdx - 277][1];
		}
	}
	else if (ctxIdx >= 338 && ctxIdx <= 398)
	{
		const int8_t mn[4][61][2] =
		{
			{
				{15, 6}, {6, 19}, {7, 16}, {12, 14}, {18, 13}, {13, 11}, {13, 15}, {15, 16}, {12, 23}, {13, 23},
				{15, 20}, {14, 26}, {14, 44}, {17, 40}, {17, 47}, {24, 17}, {21, 21}, {25, 22}, {31, 27}, {22, 29},
				{19, 35}, {14, 50}, {10, 57}, {7, 63}, {-2, 77}, {-4, 82}, {-3, 94}, {9, 69}, {-12, 109}, {36, -35},
				{36, -34}, {32, -26}, {37, -30}, {44, -32}, {34, -18}, {34, -15}, {40, -15}, {33, -7}, {35, -5}, {33, 0},
				{38, 2}, {33, 13}, {23, 35}, {13, 58}, {29, -3}, {26, 0}, {22, 30}, {31, -7}, {35, -15}, {34, -3},
				{34, 3}, {36, -1}, {34, 5}, {32, 11}, {35, 5}, {34, 12}, {39, 11}, {30, 29}, {34, 26}, {29, 39},
				{19, 66}
			},
			{
				{14, 11}, {11, 14}, {9, 11}, {18, 11}, {21, 9}, {23, -2}, {32, -15}, {32, -15}, {34, -21}, {39, -23},
				{42, -33}, {41, -31}, {46, -28}, {38, -12}, {21, 29}, {45, -24}, {53, -45}, {48, -26}, {65, -43}, {43, -19},
				{39, -10}, {30, 9}, {18, 26}, {20, 27}, {0, 57}, {-14, 82}, {-5, 75}, {-19, 97}, {-35, 125}, {27, 0},
				{28, 0}, {31, -4}, {27, 6}, {34, 8}, {30, 10}, {24, 22}, {33, 19}, {22, 32}, {26, 31}, {21, 41},
				{26, 44}, {23, 47}, {16, 65}, {14, 71}, {8, 60}, {6, 63}, {17, 65}, {21, 24}, {23, 20}, {26, 23},
				{27, 32}, {28, 23}, {28, 24}, {23, 40}, {24, 32}, {28, 29}, {23, 42}, {19, 57}, {22, 53}, {22, 61},
				{11, 86}
			},
			{
				{19, -6}, {18, -6}, {14, 0}, {26, -12}, {31, -16}, {33, -25}, {33, -22}, {37, -28}, {39, -30}, {42, -30},
				{47, -42}, {45, -36}, {49, -34}, {41, -17}, {32, 9}, {69, -71}, {63, -63}, {66, -64}, {77, -74}, {54, -39},
				{52, -35}, {41, -10}, {36, 0}, {40, -1}, {30, 14}, {28, 26}, {23, 37}, {12, 55}, {11, 65}, {37, -33},
				{39, -36}, {40, -37}, {38, -30}, {46, -33}, {42, -30}, {40, -24}, {49, -29}, {38, -12}, {40, -10}, {38, -3},
				{46, -5}, {31, 20}, {29, 30}, {25, 44}, {12, 48}, {11, 49}, {26, 45}, {22, 22}, {23, 22}, {27, 21},
				{33, 20}, {26, 28}, {30, 24}, {27, 34}, {18, 42}, {25, 39}, {18, 50}, {12, 70}, {21, 54}, {14, 71},
				{11, 83}
			},
			{
				{17, -13}, {16, -9}, {17, -12}, {27, -21}, {37, -30}, {41, -40}, {42, -41}, {48, -47}, {39, -32}, {46, -40},
				{52, -51}, {46, -41}, {52, -39}, {43, -19}, {32, 11}, {61, -55}, {56, -46}, {62, -50}, {81, -67}, {45, -20},
				{35, -2}, {28, 15}, {34, 1}, {39, 1}, {30, 17}, {20, 38}, {18, 45}, {15, 54}, {0, 79}, {36, -16},
				{37, -14}, {37, -17}, {32, 1}, {34, 15}, {29, 15}, {24, 25}, {34, 22}, {31, 16}, {35, 18}, {31, 28},
				{33, 41}, {36, 28}, {27, 47}, {21, 62}, {18, 31}, {19, 26}, {36, 24}, {24, 23}, {27, 16}, {24, 30},
				{31, 29}, {22, 41}, {22, 42}, {16, 60}, {15, 52}, {14, 60}, {3, 78}, {-16, 123}, {21, 53}, {22, 56},
				{25, 61}
			}
		};

		if (slice_type == SLIECETYPE::H264_SLIECE_TYPE_I || slice_type == SLIECETYPE::H264_SLIECE_TYPE_SI)
		{
			m = mn[0][ctxIdx - 338][0];
			n = mn[0][ctxIdx - 338][1];
		}
		else
		{
			m = mn[cabac_init_idc + 1][ctxIdx - 338][0];
			n = mn[cabac_init_idc + 1][ctxIdx - 338][1];
		}
	}
	else if (ctxIdx >= 402 && ctxIdx <= 459)
	{
		const int8_t mn[4][58][2] =
		{
			{
				{-17, 120}, {-20, 112}, {-18, 114}, {-11, 85}, {-15, 92}, {-14, 89}, {-26, 71}, {-15, 81}, {-14, 80}, {0, 68},
				{-14, 70}, {-24, 56}, {-23, 68}, {-24, 50}, {-11, 74}, {23, -13}, {26, -13}, {40, -15}, {49, -14}, {44, 3},
				{45, 6}, {44, 34}, {33, 54}, {19, 82}, {-3, 75}, {-1, 23}, {1, 34}, {1, 43}, {0, 54}, {-2, 55},
				{0, 61}, {1, 64}, {0, 68}, {-9, 92}, {-14, 106}, {-13, 97}, {-15, 90}, {-12, 90}, {-18, 88}, {-10, 73},
				{-9, 79}, {-14, 86}, {-10, 73}, {-10, 70}, {-10, 69}, {-5, 66}, {-9, 64}, {-5, 58}, {2, 59}, {21, -10},
				{24, -11}, {28, -8}, {28, -1}, {29, 3}, {29, 9}, {35, 20}, {29, 36}, {14, 67}
			},
			{
				{-4, 79}, {-7, 71}, {-5, 69}, {-9, 70}, {-8, 66}, {-10, 68}, {-19, 73}, {-12, 69}, {-16, 70}, {-15, 67},
				{-20, 62}, {-19, 70}, {-16, 66}, {-22, 65}, {-20, 63}, {9, -2}, {26, -9}, {33, -9}, {39, -7}, {41, -2},
				{45, 3}, {49, 9}, {45, 27}, {36, 59}, {-6, 66}, {-7, 35}, {-7, 42}, {-8, 45}, {-5, 48}, {-12, 56},
				{-6, 60}, {-5, 62}, {-8, 66}, {-8, 76}, {-5, 85}, {-6, 81}, {-10, 77}, {-7, 81}, {-17, 80}, {-18, 73},
				{-4, 74}, {-10, 83}, {-9, 71}, {-9, 67}, {-1, 61}, {-8, 66}, {-14, 66}, {0, 59}, {2, 59}, {21, -13},
				{33, -14}, {39, -7}, {46, -2}, {51, 2}, {60, 6}, {61, 17}, {55, 34}, {42, 62}
			},
			{
				{-5, 85}, {-6, 81}, {-10, 77}, {-7, 81}, {-17, 80}, {-18, 73}, {-4, 74}, {-10, 83}, {-9, 71}, {-9, 67},
				{-1, 61}, {-8, 66}, {-14, 66}, {0, 59}, {2, 59}, {17, -10}, {32, -13}, {42, -9}, {49, -5}, {53, 0},
				{64, 3}, {68, 10}, {66, 27}, {47, 57}, {-5, 71}, {0, 24}, {-1, 36}, {-2, 42}, {-2, 52}, {-9, 57},
				{-6, 63}, {-4, 65}, {-4, 67}, {-7, 82}, {-3, 81}, {-3, 76}, {-7, 72}, {-6, 78}, {-12, 72}, {-14, 68},
				{-3, 70}, {-6, 76}, {-5, 66}, {-5, 62}, {0, 57}, {-4, 61}, {-9, 60}, {1, 54}, {2, 58}, {17, -10},
				{32, -13}, {42, -9}, {49, -5}, {53, 0}, {64, 3}, {68, 10}, {66, 27}, {47, 57}
			},
			{
				{-3, 78}, {-8, 74}, {-9, 72}, {-10, 72}, {-18, 75}, {-12, 71}, {-11, 63}, {-5, 70}, {-17, 75}, {-14, 72},
				{-16, 67}, {-8, 53}, {-14, 59}, {-9, 52}, {-11, 68}, {9, -2}, {30, -10}, {31, -4}, {33, -1}, {33, 7},
				{31, 12}, {37, 23}, {31, 38}, {20, 64}, {-9, 71}, {-7, 37}, {-8, 44}, {-11, 49}, {-10, 56}, {-12, 59},
				{-8, 63}, {-9, 67}, {-6, 68}, {-10, 79}, {-3, 78}, {-8, 74}, {-9, 72}, {-10, 72}, {-18, 75}, {-12, 71},
				{-11, 63}, {-5, 70}, {-17, 75}, {-14, 72}, {-16, 67}, {-8, 53}, {-14, 59}, {-9, 52}, {-11, 68}, {9, -2},
				{30, -10}, {31, -4}, {33, -1}, {33, 7}, {31, 12}, {37, 23}, {31, 38}, {20, 64}
			}
		};

		if (slice_type == SLIECETYPE::H264_SLIECE_TYPE_I)
		{
			m = mn[0][ctxIdx - 402][0];
			n = mn[0][ctxIdx - 402][1];
		}
		else
		{
			m = mn[cabac_init_idc + 1][ctxIdx - 402][0];
			n = mn[cabac_init_idc + 1][ctxIdx - 402][1];
		}
	}
	else if (ctxIdx >= 460 && ctxIdx <= 483)
	{
		const int8_t mn[4][24][2] =
		{
			{
				{-17, 123}, {-12, 115}, {-16, 122}, {-11, 115}, {-12, 63}, {-2, 68}, {-15, 84}, {-13, 104}, {-3, 70}, {-8, 93},
				{-10, 90}, {-30, 127}, {-17, 123}, {-12, 115}, {-16, 122}, {-11, 115}, {-12, 63}, {-2, 68}, {-15, 84}, {-13, 104},
				{-3, 70}, {-8, 93}, {-10, 90}, {-30, 127}
			},
			{
				{-7, 92}, {-5, 89}, {-7, 96}, {-13, 108}, {-3, 46}, {-1, 65}, {-1, 57}, {-9, 93}, {-3, 74}, {-9, 92},
				{-8, 87}, {-23, 126}, {-7, 92}, {-5, 89}, {-7, 96}, {-13, 108}, {-3, 46}, {-1, 65}, {-1, 57}, {-9, 93},
				{-3, 74}, {-9, 92}, {-8, 87}, {-23, 126}
			},
			{
				{0, 80}, {-5, 89}, {-7, 94}, {-4, 92}, {0, 39}, {0, 65}, {-15, 84}, {-35, 127}, {-2, 73}, {-12, 104},
				{-9, 91}, {-31, 127}, {0, 80}, {-5, 89}, {-7, 94}, {-4, 92}, {0, 39}, {0, 65}, {-15, 84}, {-35, 127},
				{-2, 73}, {-12, 104}, {-9, 91}, {-31, 127}
			},
			{
				{11, 80}, {5, 76}, {2, 84}, {5, 78}, {-6, 55}, {4, 61}, {-14, 83}, {-37, 127}, {-5, 79}, {-11, 104},
				{-11, 91}, {-30, 127}, {11, 80}, {5, 76}, {2, 84}, {5, 78}, {-6, 55}, {4, 61}, {-14, 83}, {-37, 127},
				{-5, 79}, {-11, 104}, {-11, 91}, {-30, 127}
			}
		};

		if (slice_type == SLIECETYPE::H264_SLIECE_TYPE_I || slice_type == SLIECETYPE::H264_SLIECE_TYPE_SI)
		{
			m = mn[0][ctxIdx - 460][0];
			n = mn[0][ctxIdx - 460][1];
		}
		else
		{
			m = mn[cabac_init_idc + 1][ctxIdx - 460][0];
			n = mn[cabac_init_idc + 1][ctxIdx - 460][1];
		}
	}
	else if (ctxIdx >= 484 && ctxIdx <= 571)
	{
		const int8_t mn[4][88][2] =
		{
			{
				{-7, 93}, {-11, 87}, {-3, 77}, {-5, 71}, {-4, 63}, {-4, 68}, {-12, 84}, {-7, 62}, {-7, 65}, {8, 61},
				{5, 56}, {-2, 66}, {1, 64}, {0, 61}, {-2, 78}, {1, 50}, {7, 52}, {10, 35}, {0, 44}, {11, 38},
				{1, 45}, {0, 46}, {5, 44}, {31, 17}, {1, 51}, {7, 50}, {28, 19}, {16, 33}, {14, 62}, {-13, 108},
				{-15, 100}, {-13, 101}, {-13, 91}, {-12, 94}, {-10, 88}, {-16, 84}, {-10, 86}, {-7, 83}, {-13, 87}, {-19, 94},
				{1, 70}, {0, 72}, {-5, 74}, {18, 59}, {-7, 93}, {-11, 87}, {-3, 77}, {-5, 71}, {-4, 63}, {-4, 68},
				{-12, 84}, {-7, 62}, {-7, 65}, {8, 61}, {5, 56}, {-2, 66}, {1, 64}, {0, 61}, {-2, 78}, {1, 50},
				{7, 52}, {10, 35}, {0, 44}, {11, 38}, {1, 45}, {0, 46}, {5, 44}, {31, 17}, {1, 51}, {7, 50},
				{28, 19}, {16, 33}, {14, 62}, {-13, 108}, {-15, 100}, {-13, 101}, {-13, 91}, {-12, 94}, {-10, 88}, {-16, 84},
				{-10, 86}, {-7, 83}, {-13, 87}, {-19, 94}, {1, 70}, {0, 72}, {-5, 74}, {18, 59}
			},
			{
				{-2, 85}, {-6, 78}, {-1, 75}, {-7, 77}, {2, 54}, {5, 50}, {-3, 68}, {1, 50}, {6, 42}, {-4, 81},
				{1, 63}, {-4, 70}, {0, 67}, {2, 57}, {-2, 76}, {11, 35}, {4, 64}, {1, 61}, {11, 35}, {18, 25},
				{12, 24}, {13, 29}, {13, 36}, {-10, 93}, {-7, 73}, {-2, 73}, {13, 46}, {9, 49}, {-7, 100}, {9, 53},
				{2, 53}, {5, 53}, {-2, 61}, {0, 56}, {0, 56}, {-13, 63}, {-5, 60}, {-1, 62}, {4, 57}, {-6, 69},
				{4, 57}, {14, 39}, {4, 51}, {13, 68}, {-2, 85}, {-6, 78}, {-1, 75}, {-7, 77}, {2, 54}, {5, 50},
				{-3, 68}, {1, 50}, {6, 42}, {-4, 81}, {1, 63}, {-4, 70}, {0, 67}, {2, 57}, {-2, 76}, {11, 35},
				{4, 64}, {1, 61}, {11, 35}, {18, 25}, {12, 24}, {13, 29}, {13, 36}, {-10, 93}, {-7, 73}, {-2, 73},
				{13, 46}, {9, 49}, {-7, 100}, {9, 53}, {2, 53}, {5, 53}, {-2, 61}, {0, 56}, {0, 56}, {-13, 63},
				{-5, 60}, {-1, 62}, {4, 57}, {-6, 69}, {4, 57}, {14, 39}, {4, 51}, {13, 68}

			},
			{
				{-13, 103}, {-13, 91}, {-9, 89}, {-14, 92}, {-8, 76}, {-12, 87}, {-23, 110}, {-24, 105}, {-10, 78}, {-20, 112},
				{-17, 99}, {-78, 127}, {-70, 127}, {-50, 127}, {-46, 127}, {-4, 66}, {-5, 78}, {-4, 71}, {-8, 72}, {2, 59},
				{-1, 55}, {-7, 70}, {-6, 75}, {-8, 89}, {-34, 119}, {-3, 75}, {32, 20}, {30, 22}, {-44, 127}, {0, 54},
				{-5, 61}, {0, 58}, {-1, 60}, {-3, 61}, {-8, 67}, {-25, 84}, {-14, 74}, {-5, 65}, {5, 52}, {2, 57},
				{0, 61}, {-9, 69}, {-11, 70}, {18, 55}, {-13, 103}, {-13, 91}, {-9, 89}, {-14, 92}, {-8, 76}, {-12, 87},
				{-23, 110}, {-24, 105}, {-10, 78}, {-20, 112}, {-17, 99}, {-78, 127}, {-70, 127}, {-50, 127}, {-46, 127}, {-4, 66},
				{-5, 78}, {-4, 71}, {-8, 72}, {2, 59}, {-1, 55}, {-7, 70}, {-6, 75}, {-8, 89}, {-34, 119}, {-3, 75},
				{32, 20}, {30, 22}, {-44, 127}, {0, 54}, {-5, 61}, {0, 58}, {-1, 60}, {-3, 61}, {-8, 67}, {-25, 84},
				{-14, 74}, {-5, 65}, {5, 52}, {2, 57}, {0, 61}, {-9, 69}, {-11, 70}, {18, 55}
			},
			{
				{-4, 86}, {-12, 88}, {-5, 82}, {-3, 72}, {-4, 67}, {-8, 72}, {-16, 89}, {-9, 69}, {-1, 59}, {5, 66},
				{4, 57}, {-4, 71}, {-2, 71}, {2, 58}, {-1, 74}, {-4, 44}, {-1, 69}, {0, 62}, {-7, 51}, {-4, 47},
				{-6, 42}, {-3, 41}, {-6, 53}, {8, 76}, {-9, 78}, {-11, 83}, {9, 52}, {0, 67}, {-5, 90}, {1, 67},
				{-15, 72}, {-5, 75}, {-8, 80}, {-21, 83}, {-21, 64}, {-13, 31}, {-25, 64}, {-29, 94}, {9, 75}, {17, 63},
				{-8, 74}, {-5, 35}, {-2, 27}, {13, 91}, {-4, 86}, {-12, 88}, {-5, 82}, {-3, 72}, {-4, 67}, {-8, 72},
				{-16, 89}, {-9, 69}, {-1, 59}, {5, 66}, {4, 57}, {-4, 71}, {-2, 71}, {2, 58}, {-1, 74}, {-4, 44},
				{-1, 69}, {0, 62}, {-7, 51}, {-4, 47}, {-6, 42}, {-3, 41}, {-6, 53}, {8, 76}, {-9, 78}, {-11, 83},
				{9, 52}, {0, 67}, {-5, 90}, {1, 67}, {-15, 72}, {-5, 75}, {-8, 80}, {-21, 83}, {-21, 64}, {-13, 31},
				{-25, 64}, {-29, 94}, {9, 75}, {17, 63}, {-8, 74}, {-5, 35}, {-2, 27}, {13, 91}
			}
		};

		if (slice_type == SLIECETYPE::H264_SLIECE_TYPE_I || slice_type == SLIECETYPE::H264_SLIECE_TYPE_SI)
		{
			m = mn[0][ctxIdx - 484][0];
			n = mn[0][ctxIdx - 484][1];
		}
		else
		{
			m = mn[cabac_init_idc + 1][ctxIdx - 484][0];
			n = mn[cabac_init_idc + 1][ctxIdx - 484][1];
		}
	}
	else if (ctxIdx >= 572 && ctxIdx <= 659)
	{
		const int8_t mn[4][88][2] =
		{
			{
				{24, 0}, {15, 9}, {8, 25}, {13, 18}, {15, 9}, {13, 19}, {10, 37}, {12, 18}, {6, 29}, {20, 33},
				{15, 30}, {4, 45}, {1, 58}, {0, 62}, {7, 61}, {12, 38}, {11, 45}, {15, 39}, {11, 42}, {13, 44},
				{16, 45}, {12, 41}, {10, 49}, {30, 34}, {18, 42}, {10, 55}, {17, 51}, {17, 46}, {0, 89}, {26, -19},
				{22, -17}, {26, -17}, {30, -25}, {28, -20}, {33, -23}, {37, -27}, {33, -23}, {40, -28}, {38, -17}, {33, -11},
				{40, -15}, {41, -6}, {38, 1}, {41, 17}, {24, 0}, {15, 9}, {8, 25}, {13, 18}, {15, 9}, {13, 19},
				{10, 37}, {12, 18}, {6, 29}, {20, 33}, {15, 30}, {4, 45}, {1, 58}, {0, 62}, {7, 61}, {12, 38},
				{11, 45}, {15, 39}, {11, 42}, {13, 44}, {16, 45}, {12, 41}, {10, 49}, {30, 34}, {18, 42}, {10, 55},
				{17, 51}, {17, 46}, {0, 89}, {26, -19}, {22, -17}, {26, -17}, {30, -25}, {28, -20}, {33, -23}, {37, -27},
				{33, -23}, {40, -28}, {38, -17}, {33, -11}, {40, -15}, {41, -6}, {38, 1}, {41, 17}
			},
			{
				{11, 28}, {2, 40}, {3, 44}, {0, 49}, {0, 46}, {2, 44}, {2, 51}, {0, 47}, {4, 39}, {2, 62},
				{6, 46}, {0, 54}, {3, 54}, {2, 58}, {4, 63}, {6, 51}, {6, 57}, {7, 53}, {6, 52}, {6, 55},
				{11, 45}, {14, 36}, {8, 53}, {-1, 82}, {7, 55}, {-3, 78}, {15, 46}, {22, 31}, {-1, 84}, {25, 7},
				{30, -7}, {28, 3}, {28, 4}, {32, 0}, {34, -1}, {30, 6}, {30, 6}, {32, 9}, {31, 19}, {26, 27},
				{26, 30}, {37, 20}, {28, 34}, {17, 70}, {11, 28}, {2, 40}, {3, 44}, {0, 49}, {0, 46}, {2, 44},
				{2, 51}, {0, 47}, {4, 39}, {2, 62}, {6, 46}, {0, 54}, {3, 54}, {2, 58}, {4, 63}, {6, 51},
				{6, 57}, {7, 53}, {6, 52}, {6, 55}, {11, 45}, {14, 36}, {8, 53}, {-1, 82}, {7, 55}, {-3, 78},
				{15, 46}, {22, 31}, {-1, 84}, {25, 7}, {30, -7}, {28, 3}, {28, 4}, {32, 0}, {34, -1}, {30, 6},
				{30, 6}, {32, 9}, {31, 19}, {26, 27}, {26, 30}, {37, 20}, {28, 34}, {17, 70}
			},
			{
				{4, 45}, {10, 28}, {10, 31}, {33, -11}, {52, -43}, {18, 15}, {28, 0}, {35, -22}, {38, -25}, {34, 0},
				{39, -18}, {32, -12}, {102, -94}, {0, 0}, {56, -15}, {33, -4}, {29, 10}, {37, -5}, {51, -29}, {39, -9},
				{52, -34}, {69, -58}, {67, -63}, {44, -5}, {32, 7}, {55, -29}, {32, 1}, {0, 0}, {27, 36}, {33, -25},
				{34, -30}, {36, -28}, {38, -28}, {38, -27}, {34, -18}, {35, -16}, {34, -14}, {32, -8}, {37, -6}, {35, 0},
				{30, 10}, {28, 18}, {26, 25}, {29, 41}, {4, 45}, {10, 28}, {10, 31}, {33, -11}, {52, -43}, {18, 15},
				{28, 0}, {35, -22}, {38, -25}, {34, 0}, {39, -18}, {32, -12}, {102, -94}, {0, 0}, {56, -15}, {33, -4},
				{29, 10}, {37, -5}, {51, -29}, {39, -9}, {52, -34}, {69, -58}, {67, -63}, {44, -5}, {32, 7}, {55, -29},
				{32, 1}, {0, 0}, {27, 36}, {33, -25}, {34, -30}, {36, -28}, {38, -28}, {38, -27}, {34, -18}, {35, -16},
				{34, -14}, {32, -8}, {37, -6}, {35, 0}, {30, 10}, {28, 18}, {26, 25}, {29, 41}
			},
			{
				{4, 39}, {0, 42}, {7, 34}, {11, 29}, {8, 31}, {6, 37}, {7, 42}, {3, 40}, {8, 33}, {13, 43},
				{13, 36}, {4, 47}, {3, 55}, {2, 58}, {6, 60}, {8, 44}, {11, 44}, {14, 42}, {7, 48}, {4, 56},
				{4, 52}, {13, 37}, {9, 49}, {19, 58}, {10, 48}, {12, 45}, {0, 69}, {20, 33}, {8, 63}, {35, -18},
				{33, -25}, {28, -3}, {24, 10}, {27, 0}, {34, -14}, {52, -44}, {39, -24}, {19, 17}, {31, 25}, {36, 29},
				{24, 33}, {34, 15}, {30, 20}, {22, 73}, {4, 39}, {0, 42}, {7, 34}, {11, 29}, {8, 31}, {6, 37},
				{7, 42}, {3, 40}, {8, 33}, {13, 43}, {13, 36}, {4, 47}, {3, 55}, {2, 58}, {6, 60}, {8, 44},
				{11, 44}, {14, 42}, {7, 48}, {4, 56}, {4, 52}, {13, 37}, {9, 49}, {19, 58}, {10, 48}, {12, 45},
				{0, 69}, {20, 33}, {8, 63}, {35, -18}, {33, -25}, {28, -3}, {24, 10}, {27, 0}, {34, -14}, {52, -44},
				{39, -24}, {19, 17}, {31, 25}, {36, 29}, {24, 33}, {34, 15}, {30, 20}, {22, 73}
			}
		};

		if (slice_type == SLIECETYPE::H264_SLIECE_TYPE_I || slice_type == SLIECETYPE::H264_SLIECE_TYPE_SI)
		{
			m = mn[0][ctxIdx - 572][0];
			n = mn[0][ctxIdx - 572][1];
		}
		else
		{
			m = mn[cabac_init_idc + 1][ctxIdx - 572][0];
			n = mn[cabac_init_idc + 1][ctxIdx - 572][1];
		}
	}
	else if (ctxIdx >= 660 && ctxIdx <= 717)
	{
		const int8_t mn[4][58][2] =
		{
			{
				{-17, 120}, {-20, 112}, {-18, 114}, {-11, 85}, {-15, 92}, {-14, 89}, {-26, 71}, {-15, 81}, {-14, 80}, {0, 68},
				{-14, 70}, {-24, 56}, {-23, 68}, {-24, 50}, {-11, 74}, {-14, 106}, {-13, 97}, {-15, 90}, {-12, 90}, {-18, 88},
				{-10, 73}, {-9, 79}, {-14, 86}, {-10, 73}, {-10, 70}, {-10, 69}, {-5, 66}, {-9, 64}, {-5, 58}, {2, 59},
				{23, -13}, {26, -13}, {40, -15}, {49, -14}, {44, 3}, {45, 6}, {44, 34}, {33, 54}, {19, 82}, {21, -10},
				{24, -11}, {28, -8}, {28, -1}, {29, 3}, {29, 9}, {35, 20}, {29, 36}, {14, 67}, {-3, 75}, {-1, 23},
				{1, 34}, {1, 43}, {0, 54}, {-2, 55}, {0, 61}, {1, 64}, {0, 68}, {-9, 92}
			},
			{
				{-4, 79}, {-7, 71}, {-5, 69}, {-9, 70}, {-8, 66}, {-10, 68}, {-19, 73}, {-12, 69}, {-16, 70}, {-15, 67},
				{-20, 62}, {-19, 70}, {-16, 66}, {-22, 65}, {-20, 63}, {-5, 85}, {-6, 81}, {-10, 77}, {-7, 81}, {-17, 80},
				{-18, 73}, {-4, 74}, {-10, 83}, {-9, 71}, {-9, 67}, {-1, 61}, {-8, 66}, {-14, 66}, {0, 59}, {2, 59},
				{9, -2}, {26, -9}, {33, -9}, {39, -7}, {41, -2}, {45, 3}, {49, 9}, {45, 27}, {36, 59}, {21, -13},
				{33, -14}, {39, -7}, {46, -2}, {51, 2}, {60, 6}, {61, 17}, {55, 34}, {42, 62}, {-6, 66}, {-7, 35},
				{-7, 42}, {-8, 45}, {-5, 48}, {-12, 56}, {-6, 60}, {-5, 62}, {-8, 66}, {-8, 76}
			},
			{
				{-5, 85}, {-6, 81}, {-10, 77}, {-7, 81}, {-17, 80}, {-18, 73}, {-4, 74}, {-10, 83}, {-9, 71}, {-9, 67},
				{-1, 61}, {-8, 66}, {-14, 66}, {0, 59}, {2, 59}, {-3, 81}, {-3, 76}, {-7, 72}, {-6, 78}, {-12, 72},
				{-14, 68}, {-3, 70}, {-6, 76}, {-5, 66}, {-5, 62}, {0, 57}, {-4, 61}, {-9, 60}, {1, 54}, {2, 58},
				{17, -10}, {32, -13}, {42, -9}, {49, -5}, {53, 0}, {64, 3}, {68, 10}, {66, 27}, {47, 57}, {17, -10},
				{32, -13}, {42, -9}, {49, -5}, {53, 0}, {64, 3}, {68, 10}, {66, 27}, {47, 57}, {-5, 71}, {0, 24},
				{-1, 36}, {-2, 42}, {-2, 52}, {-9, 57}, {-6, 63}, {-4, 65}, {-4, 67}, {-7, 82}
			},
			{
				{-3, 78}, {-8, 74}, {-9, 72}, {-10, 72}, {-18, 75}, {-12, 71}, {-11, 63}, {-5, 70}, {-17, 75}, {-14, 72},
				{-16, 67}, {-8, 53}, {-14, 59}, {-9, 52}, {-11, 68}, {-3, 78}, {-8, 74}, {-9, 72}, {-10, 72}, {-18, 75},
				{-12, 71}, {-11, 63}, {-5, 70}, {-17, 75}, {-14, 72}, {-16, 67}, {-8, 53}, {-14, 59}, {-9, 52}, {-11, 68},
				{9, -2}, {30, -10}, {31, -4}, {33, -1}, {33, 7}, {31, 12}, {37, 23}, {31, 38}, {20, 64}, {9, -2},
				{30, -10}, {31, -4}, {33, -1}, {33, 7}, {31, 12}, {37, 23}, {31, 38}, {20, 64}, {-9, 71}, {-7, 37},
				{-8, 44}, {-11, 49}, {-10, 56}, {-12, 59}, {-8, 63}, {-9, 67}, {-6, 68}, {-10, 79}
			}
		};

		if (slice_type == SLIECETYPE::H264_SLIECE_TYPE_I)
		{
			m = mn[0][ctxIdx - 660][0];
			n = mn[0][ctxIdx - 660][1];
		}
		else
		{
			m = mn[cabac_init_idc + 1][ctxIdx - 660][0];
			n = mn[cabac_init_idc + 1][ctxIdx - 660][1];
		}
	}
	else if (ctxIdx >= 718 && ctxIdx <= 775)
	{
		const int8_t mn[4][58][2] =
		{
			{
				{-17, 120}, {-20, 112}, {-18, 114}, {-11, 85}, {-15, 92}, {-14, 89}, {-26, 71}, {-15, 81}, {-14, 80}, {0, 68},
				{-14, 70}, {-24, 56}, {-23, 68}, {-24, 50}, {-11, 74}, {-14, 106}, {-13, 97}, {-15, 90}, {-12, 90}, {-18, 88},
				{-10, 73}, {-9, 79}, {-14, 86}, {-10, 73}, {-10, 70}, {-10, 69}, {-5, 66}, {-9, 64}, {-5, 58}, {2, 59},
				{23, -13}, {26, -13}, {40, -15}, {49, -14}, {44, 3}, {45, 6}, {44, 34}, {33, 54}, {19, 82}, {21, -10},
				{24, -11}, {28, -8}, {28, -1}, {29, 3}, {29, 9}, {35, 20}, {29, 36}, {14, 67}, {-3, 75}, {-1, 23},
				{1, 34}, {1, 43}, {0, 54}, {-2, 55}, {0, 61}, {1, 64}, {0, 68}, {-9, 92}
			},
			{
				{-4, 79}, {-7, 71}, {-5, 69}, {-9, 70}, {-8, 66}, {-10, 68}, {-19, 73}, {-12, 69}, {-16, 70}, {-15, 67},
				{-20, 62}, {-19, 70}, {-16, 66}, {-22, 65}, {-20, 63}, {-5, 85}, {-6, 81}, {-10, 77}, {-7, 81}, {-17, 80},
				{-18, 73}, {-4, 74}, {-10, 83}, {-9, 71}, {-9, 67}, {-1, 61}, {-8, 66}, {-14, 66}, {0, 59}, {2, 59},
				{9, -2}, {26, -9}, {33, -9}, {39, -7}, {41, -2}, {45, 3}, {49, 9}, {45, 27}, {36, 59}, {21, -13},
				{33, -14}, {39, -7}, {46, -2}, {51, 2}, {60, 6}, {61, 17}, {55, 34}, {42, 62}, {-6, 66}, {-7, 35},
				{-7, 42}, {-8, 45}, {-5, 48}, {-12, 56}, {-6, 60}, {-5, 62}, {-8, 66}, {-8, 76}
			},
			{
				{-5, 85}, {-6, 81}, {-10, 77}, {-7, 81}, {-17, 80}, {-18, 73}, {-4, 74}, {-10, 83}, {-9, 71}, {-9, 67},
				{-1, 61}, {-8, 66}, {-14, 66}, {0, 59}, {2, 59}, {-3, 81}, {-3, 76}, {-7, 72}, {-6, 78}, {-12, 72},
				{-14, 68}, {-3, 70}, {-6, 76}, {-5, 66}, {-5, 62}, {0, 57}, {-4, 61}, {-9, 60}, {1, 54}, {2, 58},
				{17, -10}, {32, -13}, {42, -9}, {49, -5}, {53, 0}, {64, 3}, {68, 10}, {66, 27}, {47, 57}, {17, -10},
				{32, -13}, {42, -9}, {49, -5}, {53, 0}, {64, 3}, {68, 10}, {66, 27}, {47, 57}, {-5, 71}, {0, 24},
				{-1, 36}, {-2, 42}, {-2, 52}, {-9, 57}, {-6, 63}, {-4, 65}, {-4, 67}, {-7, 82}
			},
			{
				{-3, 78}, {-8, 74}, {-9, 72}, {-10, 72}, {-18, 75}, {-12, 71}, {-11, 63}, {-5, 70}, {-17, 75}, {-14, 72},
				{-16, 67}, {-8, 53}, {-14, 59}, {-9, 52}, {-11, 68}, {-3, 78}, {-8, 74}, {-9, 72}, {-10, 72}, {-18, 75},
				{-12, 71}, {-11, 63}, {-5, 70}, {-17, 75}, {-14, 72}, {-16, 67}, {-8, 53}, {-14, 59}, {-9, 52}, {-11, 68},
				{9, -2}, {30, -10}, {31, -4}, {33, -1}, {33, 7}, {31, 12}, {37, 23}, {31, 38}, {20, 64}, {9, -2},
				{30, -10}, {31, -4}, {33, -1}, {33, 7}, {31, 12}, {37, 23}, {31, 38}, {20, 64}, {-9, 71}, {-7, 37},
				{-8, 44}, {-11, 49}, {-10, 56}, {-12, 59}, {-8, 63}, {-9, 67}, {-6, 68}, {-10, 79}
			}
		};

		if (slice_type == SLIECETYPE::H264_SLIECE_TYPE_I)
		{
			m = mn[0][ctxIdx - 718][0];
			n = mn[0][ctxIdx - 718][1];
		}
		else
		{
			m = mn[cabac_init_idc + 1][ctxIdx - 718][0];
			n = mn[cabac_init_idc + 1][ctxIdx - 718][1];
		}
	}
	else if (ctxIdx >= 776 && ctxIdx <= 863)
	{
		const int8_t mn[4][88][2] =
		{
			{
				{-6, 93}, {-6, 84}, {-8, 79}, {0, 66}, {-1, 71}, {0, 62}, {-2, 60}, {-2, 59}, {-5, 75}, {-3, 62},
				{-4, 58}, {-9, 66}, {-1, 79}, {0, 71}, {3, 68}, {10, 44}, {-7, 62}, {15, 36}, {14, 40}, {16, 27},
				{12, 29}, {1, 44}, {20, 36}, {18, 32}, {5, 42}, {1, 48}, {10, 62}, {17, 46}, {9, 64}, {-12, 104},
				{-11, 97}, {-16, 96}, {-7, 88}, {-8, 85}, {-7, 85}, {-9, 85}, {-13, 88}, {4, 66}, {-3, 77}, {-3, 76},
				{-6, 76}, {10, 58}, {-1, 76}, {-1, 83}, {-6, 93}, {-6, 84}, {-8, 79}, {0, 66}, {-1, 71}, {0, 62},
				{-2, 60}, {-2, 59}, {-5, 75}, {-3, 62}, {-4, 58}, {-9, 66}, {-1, 79}, {0, 71}, {3, 68}, {10, 44},
				{-7, 62}, {15, 36}, {14, 40}, {16, 27}, {12, 29}, {1, 44}, {20, 36}, {18, 32}, {5, 42}, {1, 48},
				{10, 62}, {17, 46}, {9, 64}, {-12, 104}, {-11, 97}, {-16, 96}, {-7, 88}, {-8, 85}, {-7, 85}, {-9, 85},
				{-13, 88}, {4, 66}, {-3, 77}, {-3, 76}, {-6, 76}, {10, 58}, {-1, 76}, {-1, 83}
			},
			{
				{-13, 106}, {-16, 106}, {-10, 87}, {-21, 114}, {-18, 110}, {-14, 98}, {-22, 110}, {-21, 106}, {-18, 103}, {-21, 107},
				{-23, 108}, {-26, 112}, {-10, 96}, {-12, 95}, {-5, 91}, {-9, 93}, {-22, 94}, {-5, 86}, {9, 67}, {-4, 80},
				{-10, 85}, {-1, 70}, {7, 60}, {9, 58}, {5, 61}, {12, 50}, {15, 50}, {18, 49}, {17, 54}, {10, 41},
				{7, 46}, {-1, 51}, {7, 49}, {8, 52}, {9, 41}, {6, 47}, {2, 55}, {13, 41}, {10, 44}, {6, 50},
				{5, 53}, {13, 49}, {4, 63}, {6, 64}, {-13, 106}, {-16, 106}, {-10, 87}, {-21, 114}, {-18, 110}, {-14, 98},
				{-22, 110}, {-21, 106}, {-18, 103}, {-21, 107}, {-23, 108}, {-26, 112}, {-10, 96}, {-12, 95}, {-5, 91}, {-9, 93},
				{-22, 94}, {-5, 86}, {9, 67}, {-4, 80}, {-10, 85}, {-1, 70}, {7, 60}, {9, 58}, {5, 61}, {12, 50},
				{15, 50}, {18, 49}, {17, 54}, {10, 41}, {7, 46}, {-1, 51}, {7, 49}, {8, 52}, {9, 41}, {6, 47},
				{2, 55}, {13, 41}, {10, 44}, {6, 50}, {5, 53}, {13, 49}, {4, 63}, {6, 64}
			},
			{
				{-21, 126}, {-23, 124}, {-20, 110}, {-26, 126}, {-25, 124}, {-17, 105}, {-27, 121}, {-27, 117}, {-17, 102}, {-26, 117},
				{-27, 116}, {-33, 122}, {-10, 95}, {-14, 100}, {-8, 95}, {-17, 111}, {-28, 114}, {-6, 89}, {-2, 80}, {-4, 82},
				{-9, 85}, {-8, 81}, {-1, 72}, {5, 64}, {1, 67}, {9, 56}, {0, 69}, {1, 69}, {7, 69}, {-7, 69},
				{-6, 67}, {-16, 77}, {-2, 64}, {2, 61}, {-6, 67}, {-3, 64}, {2, 57}, {-3, 65}, {-3, 66}, {0, 62},
				{9, 51}, {-1, 66}, {-2, 71}, {-2, 75}, {-21, 126}, {-23, 124}, {-20, 110}, {-26, 126}, {-25, 124}, {-17, 105},
				{-27, 121}, {-27, 117}, {-17, 102}, {-26, 117}, {-27, 116}, {-33, 122}, {-10, 95}, {-14, 100}, {-8, 95}, {-17, 111},
				{-28, 114}, {-6, 89}, {-2, 80}, {-4, 82}, {-9, 85}, {-8, 81}, {-1, 72}, {5, 64}, {1, 67}, {9, 56},
				{0, 69}, {1, 69}, {7, 69}, {-7, 69}, {-6, 67}, {-16, 77}, {-2, 64}, {2, 61}, {-6, 67}, {-3, 64},
				{2, 57}, {-3, 65}, {-3, 66}, {0, 62}, {9, 51}, {-1, 66}, {-2, 71}, {-2, 75}
			},
			{
				{-22, 127}, {-25, 127}, {-25, 120}, {-27, 127}, {-19, 114}, {-23, 117}, {-25, 118}, {-26, 117}, {-24, 113}, {-28, 118},
				{-31, 120}, {-37, 124}, {-10, 94}, {-15, 102}, {-10, 99}, {-13, 106}, {-50, 127}, {-5, 92}, {17, 57}, {-5, 86},
				{-13, 94}, {-12, 91}, {-2, 77}, {0, 71}, {-1, 73}, {4, 64}, {-7, 81}, {5, 64}, {15, 57}, {1, 67},
				{0, 68}, {-10, 67}, {1, 68}, {0, 77}, {2, 64}, {0, 68}, {-5, 78}, {7, 55}, {5, 59}, {2, 65},
				{14, 54}, {15, 44}, {5, 60}, {2, 70}, {-22, 127}, {-25, 127}, {-25, 120}, {-27, 127}, {-19, 114}, {-23, 117},
				{-25, 118}, {-26, 117}, {-24, 113}, {-28, 118}, {-31, 120}, {-37, 124}, {-10, 94}, {-15, 102}, {-10, 99}, {-13, 106},
				{-50, 127}, {-5, 92}, {17, 57}, {-5, 86}, {-13, 94}, {-12, 91}, {-2, 77}, {0, 71}, {-1, 73}, {4, 64},
				{-7, 81}, {5, 64}, {15, 57}, {1, 67}, {0, 68}, {-10, 67}, {1, 68}, {0, 77}, {2, 64}, {0, 68},
				{-5, 78}, {7, 55}, {5, 59}, {2, 65}, {14, 54}, {15, 44}, {5, 60}, {2, 70}
			}
		};

		if (slice_type == SLIECETYPE::H264_SLIECE_TYPE_I || slice_type == SLIECETYPE::H264_SLIECE_TYPE_SI)
		{
			m = mn[0][ctxIdx - 776][0];
			n = mn[0][ctxIdx - 776][1];
		}
		else
		{
			m = mn[cabac_init_idc + 1][ctxIdx - 776][0];
			n = mn[cabac_init_idc + 1][ctxIdx - 776][1];
		}
	}
	else if (ctxIdx >= 864 && ctxIdx <= 951)
	{
		const int8_t mn[4][88][2] =
		{
			{
				{15, 6}, {6, 19}, {7, 16}, {12, 14}, {18, 13}, {13, 11}, {13, 15}, {15, 16}, {12, 23}, {13, 23},
				{15, 20}, {14, 26}, {14, 44}, {17, 40}, {17, 47}, {24, 17}, {21, 21}, {25, 22}, {31, 27}, {22, 29},
				{19, 35}, {14, 50}, {10, 57}, {7, 63}, {-2, 77}, {-4, 82}, {-3, 94}, {9, 69}, {-12, 109}, {36, -35},
				{36, -34}, {32, -26}, {37, -30}, {44, -32}, {34, -18}, {34, -15}, {40, -15}, {33, -7}, {35, -5}, {33, 0},
				{38, 2}, {33, 13}, {23, 35}, {13, 58}, {15, 6}, {6, 19}, {7, 16}, {12, 14}, {18, 13}, {13, 11},
				{13, 15}, {15, 16}, {12, 23}, {13, 23}, {15, 20}, {14, 26}, {14, 44}, {17, 40}, {17, 47}, {24, 17},
				{21, 21}, {25, 22}, {31, 27}, {22, 29}, {19, 35}, {14, 50}, {10, 57}, {7, 63}, {-2, 77}, {-4, 82},
				{-3, 94}, {9, 69}, {-12, 109}, {36, -35}, {36, -34}, {32, -26}, {37, -30}, {44, -32}, {34, -18}, {34, -15},
				{40, -15}, {33, -7}, {35, -5}, {33, 0}, {38, 2}, {33, 13}, {23, 35}, {13, 58}
			},
			{
				{14, 11}, {11, 14}, {9, 11}, {18, 11}, {21, 9}, {23, -2}, {32, -15}, {32, -15}, {34, -21}, {39, -23},
				{42, -33}, {41, -31}, {46, -28}, {38, -12}, {21, 29}, {45, -24}, {53, -45}, {48, -26}, {65, -43}, {43, -19},
				{39, -10}, {30, 9}, {18, 26}, {20, 27}, {0, 57}, {-14, 82}, {-5, 75}, {-19, 97}, {-35, 125}, {27, 0},
				{28, 0}, {31, -4}, {27, 6}, {34, 8}, {30, 10}, {24, 22}, {33, 19}, {22, 32}, {26, 31}, {21, 41},
				{26, 44}, {23, 47}, {16, 65}, {14, 71}, {14, 11}, {11, 14}, {9, 11}, {18, 11}, {21, 9}, {23, -2},
				{32, -15}, {32, -15}, {34, -21}, {39, -23}, {42, -33}, {41, -31}, {46, -28}, {38, -12}, {21, 29}, {45, -24},
				{53, -45}, {48, -26}, {65, -43}, {43, -19}, {39, -10}, {30, 9}, {18, 26}, {20, 27}, {0, 57}, {-14, 82},
				{-5, 75}, {-19, 97}, {-35, 125}, {27, 0}, {28, 0}, {31, -4}, {27, 6}, {34, 8}, {30, 10}, {24, 22},
				{33, 19}, {22, 32}, {26, 31}, {21, 41}, {26, 44}, {23, 47}, {16, 65}, {14, 71}
			},
			{
				{19, -6}, {18, -6}, {14, 0}, {26, -12}, {31, -16}, {33, -25}, {33, -22}, {37, -28}, {39, -30}, {42, -30},
				{47, -42}, {45, -36}, {49, -34}, {41, -17}, {32, 9}, {69, -71}, {63, -63}, {66, -64}, {77, -74}, {54, -39},
				{52, -35}, {41, -10}, {36, 0}, {40, -1}, {30, 14}, {28, 26}, {23, 37}, {12, 55}, {11, 65}, {37, -33},
				{39, -36}, {40, -37}, {38, -30}, {46, -33}, {42, -30}, {40, -24}, {49, -29}, {38, -12}, {40, -10}, {38, -3},
				{46, -5}, {31, 20}, {29, 30}, {25, 44}, {19, -6}, {18, -6}, {14, 0}, {26, -12}, {31, -16}, {33, -25},
				{33, -22}, {37, -28}, {39, -30}, {42, -30}, {47, -42}, {45, -36}, {49, -34}, {41, -17}, {32, 9}, {69, -71},
				{63, -63}, {66, -64}, {77, -74}, {54, -39}, {52, -35}, {41, -10}, {36, 0}, {40, -1}, {30, 14}, {28, 26},
				{23, 37}, {12, 55}, {11, 65}, {37, -33}, {39, -36}, {40, -37}, {38, -30}, {46, -33}, {42, -30}, {40, -24},
				{49, -29}, {38, -12}, {40, -10}, {38, -3}, {46, -5}, {31, 20}, {29, 30}, {25, 44}
			},
			{
				{17, -13}, {16, -9}, {17, -12}, {27, -21}, {37, -30}, {41, -40}, {42, -41}, {48, -47}, {39, -32}, {46, -40},
				{52, -51}, {46, -41}, {52, -39}, {43, -19}, {32, 11}, {61, -55}, {56, -46}, {62, -50}, {81, -67}, {45, -20},
				{35, -2}, {28, 15}, {34, 1}, {39, 1}, {30, 17}, {20, 38}, {18, 45}, {15, 54}, {0, 79}, {36, -16},
				{37, -14}, {37, -17}, {32, 1}, {34, 15}, {29, 15}, {24, 25}, {34, 22}, {31, 16}, {35, 18}, {31, 28},
				{33, 41}, {36, 28}, {27, 47}, {21, 62}, {17, -13}, {16, -9}, {17, -12}, {27, -21}, {37, -30}, {41, -40},
				{42, -41}, {48, -47}, {39, -32}, {46, -40}, {52, -51}, {46, -41}, {52, -39}, {43, -19}, {32, 11}, {61, -55},
				{56, -46}, {62, -50}, {81, -67}, {45, -20}, {35, -2}, {28, 15}, {34, 1}, {39, 1}, {30, 17}, {20, 38},
				{18, 45}, {15, 54}, {0, 79}, {36, -16}, {37, -14}, {37, -17}, {32, 1}, {34, 15}, {29, 15}, {24, 25},
				{34, 22}, {31, 16}, {35, 18}, {31, 28}, {33, 41}, {36, 28}, {27, 47}, {21, 62}
			}
		};

		if (slice_type == SLIECETYPE::H264_SLIECE_TYPE_I || slice_type == SLIECETYPE::H264_SLIECE_TYPE_SI)
		{
			m = mn[0][ctxIdx - 864][0];
			n = mn[0][ctxIdx - 864][1];
		}
		else
		{
			m = mn[cabac_init_idc + 1][ctxIdx - 864][0];
			n = mn[cabac_init_idc + 1][ctxIdx - 864][1];
		}
	}
	else if (ctxIdx >= 952 && ctxIdx <= 1011)
	{
		const int8_t mn[4][60][2] =
		{
			{
				{-3, 71}, {-6, 42}, {-5, 50}, {-3, 54}, {-2, 62}, {0, 58}, {1, 63}, {-2, 72}, {-1, 74}, {-9, 91},
				{-5, 67}, {-5, 27}, {-3, 39}, {-2, 44}, {0, 46}, {-16, 64}, {-8, 68}, {-10, 78}, {-6, 77}, {-10, 86},
				{-12, 92}, {-15, 55}, {-10, 60}, {-6, 62}, {-4, 65}, {-12, 73}, {-8, 76}, {-7, 80}, {-9, 88}, {-17, 110},
				{-3, 71}, {-6, 42}, {-5, 50}, {-3, 54}, {-2, 62}, {0, 58}, {1, 63}, {-2, 72}, {-1, 74}, {-9, 91},
				{-5, 67}, {-5, 27}, {-3, 39}, {-2, 44}, {0, 46}, {-16, 64}, {-8, 68}, {-10, 78}, {-6, 77}, {-10, 86},
				{-12, 92}, {-15, 55}, {-10, 60}, {-6, 62}, {-4, 65}, {-12, 73}, {-8, 76}, {-7, 80}, {-9, 88}, {-17, 110}
			},
			{
				{-6, 76}, {-2, 44}, {0, 45}, {0, 52}, {-3, 64}, {-2, 59}, {-4, 70}, {-4, 75}, {-8, 82}, {-17, 102},
				{-9, 77}, {3, 24}, {0, 42}, {0, 48}, {0, 55}, {-6, 59}, {-7, 71}, {-12, 83}, {-11, 87}, {-30, 119},
				{1, 58}, {-3, 29}, {-1, 36}, {1, 38}, {2, 43}, {-6, 55}, {0, 58}, {0, 64}, {-3, 74}, {-10, 90},
				{-6, 76}, {-2, 44}, {0, 45}, {0, 52}, {-3, 64}, {-2, 59}, {-4, 70}, {-4, 75}, {-8, 82}, {-17, 102},
				{-9, 77}, {3, 24}, {0, 42}, {0, 48}, {0, 55}, {-6, 59}, {-7, 71}, {-12, 83}, {-11, 87}, {-30, 119},
				{1, 58}, {-3, 29}, {-1, 36}, {1, 38}, {2, 43}, {-6, 55}, {0, 58}, {0, 64}, {-3, 74}, {-10, 90}
			},
			{
				{-23, 112}, {-15, 71}, {-7, 61}, {0, 53}, {-5, 66}, {-11, 77}, {-9, 80}, {-9, 84}, {-10, 87}, {-34, 127},
				{-21, 101}, {-3, 39}, {-5, 53}, {-7, 61}, {-11, 75}, {-15, 77}, {-17, 91}, {-25, 107}, {-25, 111}, {-28, 122},
				{-11, 76}, {-10, 44}, {-10, 52}, {-10, 57}, {-9, 58}, {-16, 72}, {-7, 69}, {-4, 69}, {-5, 74}, {-9, 86},
				{-23, 112}, {-15, 71}, {-7, 61}, {0, 53}, {-5, 66}, {-11, 77}, {-9, 80}, {-9, 84}, {-10, 87}, {-34, 127},
				{-21, 101}, {-3, 39}, {-5, 53}, {-7, 61}, {-11, 75}, {-15, 77}, {-17, 91}, {-25, 107}, {-25, 111}, {-28, 122},
				{-11, 76}, {-10, 44}, {-10, 52}, {-10, 57}, {-9, 58}, {-16, 72}, {-7, 69}, {-4, 69}, {-5, 74}, {-9, 86}
			},
			{
				{-24, 115}, {-22, 82}, {-9, 62}, {0, 53}, {0, 59}, {-14, 85}, {-13, 89}, {-13, 94}, {-11, 92}, {-29, 127},
				{-21, 100}, {-14, 57}, {-12, 67}, {-11, 71}, {-10, 77}, {-21, 85}, {-16, 88}, {-23, 104}, {-15, 98}, {-37, 127},
				{-10, 82}, {-8, 48}, {-8, 61}, {-8, 66}, {-7, 70}, {-14, 75}, {-10, 79}, {-9, 83}, {-12, 92}, {-18, 108},
				{-24, 115}, {-22, 82}, {-9, 62}, {0, 53}, {0, 59}, {-14, 85}, {-13, 89}, {-13, 94}, {-11, 92}, {-29, 127},
				{-21, 100}, {-14, 57}, {-12, 67}, {-11, 71}, {-10, 77}, {-21, 85}, {-16, 88}, {-23, 104}, {-15, 98}, {-37, 127},
				{-10, 82}, {-8, 48}, {-8, 61}, {-8, 66}, {-7, 70}, {-14, 75}, {-10, 79}, {-9, 83}, {-12, 92}, {-18, 108}
			}
		};

		if (slice_type == SLIECETYPE::H264_SLIECE_TYPE_I || slice_type == SLIECETYPE::H264_SLIECE_TYPE_SI)
		{
			m = mn[0][ctxIdx - 952][0];
			n = mn[0][ctxIdx - 952][1];
		}
		else
		{
			m = mn[cabac_init_idc + 1][ctxIdx - 952][0];
			n = mn[cabac_init_idc + 1][ctxIdx - 952][1];
		}
	}
	else if (ctxIdx >= 1012 && ctxIdx <= 1023)
	{
		const int8_t mn[4][12][2] =
		{
			{
				{-3, 70}, {-8, 93}, {-10, 90}, {-30, 127}, {-3, 70}, {-8, 93}, {-10, 90}, {-30, 127}, {-3, 70}, {-8, 93},
				{-10, 90}, {-30, 127}
			},
			{
				{-3, 74}, {-9, 92}, {-8, 87}, {-23, 126}, {-3, 74}, {-9, 92}, {-8, 87}, {-23, 126}, {-3, 74}, {-9, 92},
			   {-8, 87}, {-23, 126}
			},
			{
				{-2, 73}, {-12, 104}, {-9, 91}, {-31, 127}, {-2, 73}, {-12, 104}, {-9, 91}, {-31, 127}, {-2, 73}, {-12, 104},
				{-9, 91}, {-31, 127}
			},
			{
				{-5, 79}, {-11, 104}, {-11, 91}, {-30, 127}, {-5, 79}, {-11, 104}, {-11, 91}, {-30, 127}, {-5, 79}, {-11, 104},
				{-11, 91}, {-30, 127}
			}
		};

		if (slice_type == SLIECETYPE::H264_SLIECE_TYPE_I || slice_type == SLIECETYPE::H264_SLIECE_TYPE_SI)
		{
			m = mn[0][ctxIdx - 1012][0];
			n = mn[0][ctxIdx - 1012][1];
		}
		else
		{
			m = mn[cabac_init_idc + 1][ctxIdx - 1012][0];
			n = mn[cabac_init_idc + 1][ctxIdx - 1012][1];
		}
	}
	else if (ctxIdx == 276)
	{
		printError("ctxIdx=276");
		//return -1; //ctxIdx = 276 is assigned to the binIdx of mb_type indicating the I_PCM mode.
	}
}


int Cabac::decode_mb_skip_flag(BitStream& bs, ParseSlice* Slice)
{
	SLIECETYPE sliceType = (SLIECETYPE)Slice->sHeader.slice_type;

	//该语法元素索引的上限，通常也可认为以最多多少个bit位来表示二值化后的语法元素；表9-34
	int maxBinIdxCtx = 0;
	//即context index offset，该值作为推导上下文索引的数据来源；
	int ctxIdxOffset = 0;

	//查找二值化过程中产生的maxBinIdxCtx和ctxIdxOffset
	if (sliceType == SLIECETYPE::H264_SLIECE_TYPE_P || sliceType == SLIECETYPE::H264_SLIECE_TYPE_SP)
	{

		maxBinIdxCtx = 0;
		ctxIdxOffset = 11;
	}
	else if (sliceType == SLIECETYPE::H264_SLIECE_TYPE_B)
	{
		maxBinIdxCtx = 0;
		ctxIdxOffset = 24;
	}
	int ctxIdxInc = Derivation_process_of_ctxIdxInc_for_the_syntax_element_mb_skip_flag(Slice);

	int ctxIdx = ctxIdxOffset + ctxIdxInc;
	//binVal 这个bit的值是0还是1
	int binVal = DecodeBin(bs, 0, ctxIdx);
	//因为要解码的只有一个bit位，所以不需要逆二值化的过程
	return binVal;
}

int Cabac::decode_mb_type(BitStream& bs, ParseSlice* Slice)
{
	int synElVal = 0;
	SLIECETYPE sliceType = (SLIECETYPE)Slice->sHeader.slice_type;

	if (sliceType == SLIECETYPE::H264_SLIECE_TYPE_SI)
	{
		synElVal = decode_mb_type_in_SI_slices(Slice, bs, 0);
	}
	else if (sliceType == SLIECETYPE::H264_SLIECE_TYPE_I)
	{
		synElVal = decode_mb_type_in_I_slices(Slice, bs, 3);
	}
	else if (sliceType == SLIECETYPE::H264_SLIECE_TYPE_P || sliceType == SLIECETYPE::H264_SLIECE_TYPE_SP)
	{
		synElVal = decode_mb_type_in_P_SP_slices(Slice, bs, 14);
	}
	else if (sliceType == SLIECETYPE::H264_SLIECE_TYPE_B)
	{
		synElVal = decode_mb_type_in_B_slices(Slice, bs, 27);
	}
	return synElVal;
}

int Cabac::decode_sub_mb_type(BitStream& bs, ParseSlice* Slice)
{
	int ctxIdxOffset = 0;

	SLIECETYPE sliceType = (SLIECETYPE)Slice->sHeader.slice_type;

	int synElVal = 0;

	if (sliceType == SLIECETYPE::H264_SLIECE_TYPE_P || sliceType == SLIECETYPE::H264_SLIECE_TYPE_SP)
	{
		synElVal = decode_sub_mb_type_in_P_SP_slices(bs);
	}
	else if (sliceType == SLIECETYPE::H264_SLIECE_TYPE_B)
	{
		//synElVal = decode_mb_type_in_I_slices(Slice, bs, 3);
		synElVal = decode_sub_mb_type_in_B_slices(bs);
	}
	return synElVal;
}

int Cabac::decode_transform_size_8x8_flag(BitStream& bs, ParseSlice* Slice)
{
	int ctxIdxOffset = 399;
	int ctxIdxInc = Derivation_process_of_ctxIdxInc_for_the_syntax_element_transform_size_8x8_flag(Slice);
	int ctxIdx = ctxIdxOffset + ctxIdxInc;

	int binVal = DecodeBin(bs, 0, ctxIdx);

	return binVal;
}

int Cabac::decode_coded_block_pattern(BitStream& bs, ParseSlice* Slice)
{
	int binVal = 0;
	int binIdx = 0;
	int ctxIdxInc = 0;
	int ctxIdx = 0;
	// ctxIdxOffset = 73表示CodedBlockPatternLuma
	// ctxIdxOffset = 77表示CodedBlockPatternChroma
	int ctxIdxOffset = 73;

	int CodedBlockPatternLuma = 0;
	//CodedBlockPatternLuma由FL二值化表示给出 cMax = 15;定长编码，解析4个bit
	//------b0--------
	binIdx = 0;
	ctxIdxInc = Derivation_process_of_ctxIdxInc_for_the_syntax_element_coded_block_pattern(Slice, ctxIdxOffset, binIdx, CodedBlockPatternLuma);
	ctxIdx = ctxIdxOffset + ctxIdxInc;
	binVal = DecodeBin(bs, false, ctxIdx);
	CodedBlockPatternLuma = binVal;

	//------b1--------
	binIdx = 1;
	ctxIdxInc = Derivation_process_of_ctxIdxInc_for_the_syntax_element_coded_block_pattern(Slice, ctxIdxOffset, binIdx, CodedBlockPatternLuma);
	ctxIdx = ctxIdxOffset + ctxIdxInc;
	binVal = DecodeBin(bs, false, ctxIdx);
	CodedBlockPatternLuma += binVal << 1;

	//------b2--------
	binIdx = 2;
	ctxIdxInc = Derivation_process_of_ctxIdxInc_for_the_syntax_element_coded_block_pattern(Slice, ctxIdxOffset, binIdx, CodedBlockPatternLuma);
	ctxIdx = ctxIdxOffset + ctxIdxInc;
	binVal = DecodeBin(bs, false, ctxIdx);
	CodedBlockPatternLuma += binVal << 2;

	//------b3--------
	binIdx = 3;
	ctxIdxInc = Derivation_process_of_ctxIdxInc_for_the_syntax_element_coded_block_pattern(Slice, ctxIdxOffset, binIdx, CodedBlockPatternLuma);
	ctxIdx = ctxIdxOffset + ctxIdxInc;
	binVal = DecodeBin(bs, false, ctxIdx);
	CodedBlockPatternLuma += binVal << 3;
	//cMax = 15，maxBinIdxCtx = 3 ,最大只有15，最多解析到binIdx = 3，停止解析


	//当ChromaArrayType不等于0或3时，后缀部分会出现
	int CodedBlockPatternChroma = 0;
	if (Slice->sHeader.sps.ChromaArrayType != 0 && Slice->sHeader.sps.ChromaArrayType != 3)
	{
		//CodedBlockPatternChroma由TU二值化表示给出 cMax = 2;截断一元二值化，等于cMax，二进制码全部为1，长度为cMax。不然最后一位为0
		ctxIdxOffset = 77;


		binIdx = 0;
		ctxIdxInc = Derivation_process_of_ctxIdxInc_for_the_syntax_element_coded_block_pattern(Slice, ctxIdxOffset, binIdx, binVal);
		ctxIdx = ctxIdxOffset + ctxIdxInc;
		binVal = DecodeBin(bs, false, ctxIdx);

		if (binVal == 0) //0
		{
			CodedBlockPatternChroma = 0;
		}
		else // 1
		{

			CodedBlockPatternChroma = 1;

			binIdx = 1;
			ctxIdxInc = Derivation_process_of_ctxIdxInc_for_the_syntax_element_coded_block_pattern(Slice, ctxIdxOffset, binIdx, binVal);
			ctxIdx = ctxIdxOffset + ctxIdxInc;
			binVal = DecodeBin(bs, false, ctxIdx);

			if (binVal == 1) //11
			{
				CodedBlockPatternChroma = 2;
				//cMax = 2，maxBinIdxCtx = 1 ,最大只有2，最多解析到binIdx = 1，停止解析
			}

		}

	}

	//把CodedBlockPatternChroma*16是因为后面要%掉CodedBlockPatternChroma，这样就剩CodedBlockPatternLuma
	//CodedBlockPatternLuma = coded_block_pattern % 16;
	//CodedBlockPatternChroma = coded_block_pattern / 16;
	return  CodedBlockPatternLuma + CodedBlockPatternChroma * 16;
}

int Cabac::decode_mb_qp_delta(BitStream& bs, ParseSlice* Slice)
{
	int ctxIdxOffset = 60;
	int ctxIdxInc = 0;
	int ctxIdx = 0;
	int binVal = 0;

	int binIdx = 0;

	ctxIdxInc = Derivation_process_of_ctxIdxInc_for_the_syntax_element_mb_qp_delta(Slice);

	ctxIdx = ctxIdxOffset + ctxIdxInc;

	binVal = DecodeBin(bs, false, ctxIdx);

	//一元二值化，就是类似 (111...1110)b 这样的二进制字符串，最后一个二进制值为0，其他都是1，其中1的个数就是对应的语法元素的值
	int synElVal = 0;
	if (binVal == 0)
	{
		synElVal = 0;
	}
	else
	{
		ctxIdx = ctxIdxOffset + 2;
		binVal = DecodeBin(bs, false, ctxIdx);
		binIdx = 1;

		while (binVal == 1)
		{
			ctxIdx = ctxIdxOffset + 3;
			binVal = DecodeBin(bs, false, ctxIdx);
			binIdx++;
		}

		//Table 9-3 se(v)
		if (binIdx & 0x01) //奇数
		{
			binIdx = (binIdx + 1) >> 1; //(−1)^(k+1) * Ceil(k÷2)
		}
		else//偶数
		{
			binIdx = -(binIdx >> 1); //(−1)^(k+1) * Ceil(k÷2)
		}

		synElVal = binIdx;
	}
	return synElVal;
}

int Cabac::decode_prev_intra4x4_pred_mode_flag_or_prev_intra8x8_pred_mode_flag(BitStream& bs)
{
	int ctxIdxOffset = 68;

	int ctxIdx = ctxIdxOffset + 0;

	int binVal = DecodeBin(bs, false, ctxIdx);

	return binVal;
}

int Cabac::decode_rem_intra4x4_pred_mode_or_rem_intra8x8_pred_mode(BitStream& bs)
{
	//FL, cMax=7
	int ctxIdxOffset = 69;
	int synElVal = 0;
	int binVal = 0;
	int ctxIdx = ctxIdxOffset + 0;

	binVal = DecodeBin(bs, false, ctxIdx);
	synElVal += binVal << 0;

	binVal = DecodeBin(bs, false, ctxIdx);
	synElVal += binVal << 1;

	binVal = DecodeBin(bs, false, ctxIdx);
	synElVal += binVal << 2;

	return synElVal;
}

int Cabac::decode_intra_chroma_pred_mode(BitStream& bs, ParseSlice* Slice)
{
	//TU, cMax=3 
	constexpr int ctxIdxOffset = 64;
	int ctxIdxInc = 0;
	int ctxIdx = 0;
	int binVal = 0;
	int synElVal = 0;

	ctxIdxInc = Derivation_process_of_ctxIdxInc_for_the_syntax_element_intra_chroma_pred_mode(Slice);
	ctxIdx = ctxIdxOffset + ctxIdxInc;

	binVal = DecodeBin(bs, false, ctxIdx);

	if (binVal == 0)
	{
		synElVal = 0;
	}
	else //1
	{
		ctxIdx = ctxIdxOffset + 3; //Table 9-39
		binVal = DecodeBin(bs, false, ctxIdx);

		if (binVal == 0) //10
		{
			synElVal = 1;
		}
		else//11
		{
			ctxIdx = ctxIdxOffset + 3; //Table 9-39
			binVal = DecodeBin(bs, false, ctxIdx);//binIdx = 2;

			if (binVal == 0) //110
			{
				synElVal = 2;
			}
			else //111
			{
				synElVal = 3;//TU, cMax=3
			}
		}
	}
	return synElVal;
}


bool Cabac::decode_coded_block_flag(ParseSlice* Slice, BitStream& bs, RESIDUAL_LEVEL residualLevel, int BlkIdx, int iCbCr)
{

	//NumC8x8 = 4 / ( SubWidthC * SubHeightC ) 
	const int NumC8x8 = 4 / (Slice->sHeader.sps.SubWidthC * Slice->sHeader.sps.SubHeightC);



	int ctxBlockCat = getCtxBlockCat(NumC8x8, residualLevel);


	//FL,cMax = 1 Table 9-34
	int ctxIdxOffset = 0;
	if (ctxBlockCat < 5)
	{
		ctxIdxOffset = 85;
	}
	else if (ctxBlockCat > 5 && ctxBlockCat < 9)
	{
		ctxIdxOffset = 460;
	}
	else if (ctxBlockCat > 9 && ctxBlockCat < 13)
	{
		ctxIdxOffset = 472;
	}
	else //if (ctxBlockCat == 5 || ctxBlockCat == 9 || ctxBlockCat == 13)
	{
		ctxIdxOffset = 1012;
	}

	constexpr int ctxIdxBlockCatOffsets[14] = { 0, 4, 8, 12, 16, 0, 0, 4, 8, 4, 0, 4, 8, 8 };
	const int ctxIdxBlockCatOffset = ctxIdxBlockCatOffsets[ctxBlockCat];

	//9.3.3.1.1.9  ctxIdxInc
	const int ctxIdxInc = Derivation_process_of_ctxIdxInc_for_the_syntax_element_coded_block_flag(Slice, ctxBlockCat, BlkIdx, iCbCr);
	const int ctxIdx = ctxIdxOffset + ctxIdxBlockCatOffset + ctxIdxInc;

	return DecodeBin(bs, false, ctxIdx);
}
bool Cabac::decode_significant_coeff_flag_and_last_significant_coeff_flag(ParseSlice* Slice, BitStream& bs, RESIDUAL_LEVEL residualLevel, int levelListIdx, bool lastFlag)
{
	const int NumC8x8 = 4 / (Slice->sHeader.sps.SubWidthC * Slice->sHeader.sps.SubHeightC);



	int ctxBlockCat = getCtxBlockCat(NumC8x8, residualLevel);
	int ctxIdxOffset = 0;

	if (ctxBlockCat < 5) //(frame coded blocks with ctxBlockCat < 5) FL, cMax=1
	{
		if (lastFlag)//last_significant_coeff_flag
		{
			ctxIdxOffset = 166;
		}
		else//significant_coeff_flag
		{
			ctxIdxOffset = 105;
		}
	}
	else if (ctxBlockCat == 5)
	{


		if (lastFlag)//last_significant_coeff_flag
		{
			ctxIdxOffset = 417;
		}
		else//significant_coeff_flag 
		{
			ctxIdxOffset = 402;
		}
	}
	else if (ctxBlockCat > 5 && ctxBlockCat < 9)
	{
		if (lastFlag)//last_significant_coeff_flag
		{
			ctxIdxOffset = 572;
		}
		else //significant_coeff_flag
		{
			ctxIdxOffset = 484;
		}
	}
	else if (ctxBlockCat > 9 && ctxBlockCat < 13)
	{

		if (lastFlag)//last_significant_coeff_flag
		{
			ctxIdxOffset = 616;
		}
		else //significant_coeff_flag
		{
			ctxIdxOffset = 528;
		}
	}
	else if (ctxBlockCat == 9)
	{

		if (lastFlag)
		{
			ctxIdxOffset = 690;
		}
		else
		{
			ctxIdxOffset = 660;
		}
	}
	else //if (ctxBlockCat == 13)
	{
		if (lastFlag)
		{
			ctxIdxOffset = 748;
		}
		else
		{
			ctxIdxOffset = 718;
		}
	}

	constexpr int ctxIdxBlockCatOffsets[14] = { 0, 15, 29, 44, 47, 0, 0, 15, 29, 0, 0, 15, 29, 0 };
	const int ctxIdxBlockCatOffset = ctxIdxBlockCatOffsets[ctxBlockCat];

	int ctxIdxInc = 0;
	if (ctxBlockCat != 3
		&& ctxBlockCat != 5
		&& ctxBlockCat != 9
		&& ctxBlockCat != 13
		)
	{
		//levelListIdx=变换系数等级列表的索引(64个系数的索引)
		ctxIdxInc = levelListIdx;
	}
	else if (ctxBlockCat == 3)
	{
		//levelListIdx 范围为[0,4×NumC8x8-2] 
		ctxIdxInc = std::min(levelListIdx / NumC8x8, 2);
	}
	else if (ctxBlockCat == 5 || ctxBlockCat == 9 || ctxBlockCat == 13)
	{
		constexpr int ctxIdxIncs[63][2] =
		{
			{0, 0},
			{1, 1},
			{2, 1},
			{3, 1},
			{4, 1},
			{5,  1},
			{5, 1},
			{4, 1},
			{4,  1},
			{3, 1},
			{3,  1},
			{4, 1},
			{4, 1},
			{4, 1},
			{5, 1},
			{5, 1},
			{4, 2},
			{4, 2},
			{4, 2},
			{4,  2},
			{3,  2},
			{3,  2},
			{6, 2},
			{7,  2},
			{7, 2},
			{7, 2},
			{8,  2},
			{9, 2},
			{10, 2},
			{9,  2},
			{8,  2},
			{7, 2},
			{7, 3},
			{6, 3},
			{11,  3},
			{12, 3},
			{13, 3},
			{11,  3},
			{6,  3},
			{7,  3},
			{8, 4},
			{9, 4},
			{14, 4},
			{10, 4},
			{9, 4},
			{8, 4},
			{6, 4},
			{11, 4},
			{12,  5},
			{13,  5},
			{11,  5},
			{6, 5},
			{9, 6},
			{14,  6},
			{10, 6},
			{9, 6},
			{11,  7},
			{12,  7},
			{13,  7},
			{11,  7},
			{14, 8},
			{10, 8},
			{12, 8}
		};
		if (lastFlag)
		{
			ctxIdxInc = ctxIdxIncs[levelListIdx][1];
		}
		else
		{
			ctxIdxInc = ctxIdxIncs[levelListIdx][0];
		}
	}

	const int ctxIdx = ctxIdxOffset + ctxIdxBlockCatOffset + ctxIdxInc;

	return DecodeBin(bs, false, ctxIdx);
}

int Cabac::decode_coeff_abs_level_minus1(ParseSlice* Slice, BitStream& bs, RESIDUAL_LEVEL residualLevel, int numDecodAbsLevelEq1, int numDecodAbsLevelGt1)
{

	const int NumC8x8 = 4 / (Slice->sHeader.sps.SubWidthC * Slice->sHeader.sps.SubHeightC);


	int ctxIdxInc = 0;
	int ctxIdx = 0;
	const int ctxBlockCat = getCtxBlockCat(NumC8x8, residualLevel);

	int ctxIdxOffset = 0;
	if (ctxBlockCat < 5) //(blocks with ctxBlockCat < 5)
	{
		ctxIdxOffset = 227;
	}
	else if (ctxBlockCat == 5)
	{
		ctxIdxOffset = 426;
	}
	else if (ctxBlockCat > 5 && ctxBlockCat < 9)
	{
		ctxIdxOffset = 952;
	}
	else if (ctxBlockCat > 9 && ctxBlockCat < 13)
	{
		ctxIdxOffset = 982;
	}
	else if (ctxBlockCat == 9)
	{
		ctxIdxOffset = 708;
	}
	else //if (ctxBlockCat == 13)
	{
		ctxIdxOffset = 766;
	}
	constexpr int ctxIdxBlockCatOffsets[14] = { 0, 10, 20, 30, 39, 0, 0, 10, 20, 0, 0, 10, 20, 0 };
	const int ctxIdxBlockCatOffset = ctxIdxBlockCatOffsets[ctxBlockCat];


	constexpr int uCoff = 14;
	int synElVal = 0;
	int binVal = 0;

	ctxIdxInc = ((numDecodAbsLevelGt1 != 0) ? 0 : std::min(4, 1 + numDecodAbsLevelEq1)); //if (binIdx == 0)
	ctxIdx = ctxIdxOffset + ctxIdxBlockCatOffset + ctxIdxInc;
	//signedValFlag=0, uCoff=14 
	//UEGk（k阶指数哥伦布编码，这里是0阶）编码是由 prefix(TU binarization) + suffix(Exp-Golomb) + signedValFlag, 三部分组成

	binVal = DecodeBin(bs, false, ctxIdx); //if (binIdx == 0)

	//解码前缀 TU 
	ctxIdxInc = 5 + std::min(4 - ((ctxBlockCat == 3) ? 1 : 0), numDecodAbsLevelGt1); //if (binIdx > 0)
	ctxIdx = ctxIdxOffset + ctxIdxBlockCatOffset + ctxIdxInc;
	while (binVal == 1)
	{
		synElVal++;

		//Min( uCoff, Abs( synElVal ) )
		if (synElVal >= uCoff)
		{
			break;
		}

		binVal = DecodeBin(bs, false, ctxIdx);//binIdx > 0
	}

	//解码后缀  Exp-Golomb（0阶哥伦布编码）
	/*如果如下条件的一个为真，带有synElVal 值的语法元素的码串仅包含前缀码串。
		— signedValFlag 等于0，前缀比特串不是长度为uCoff、所有比特为1的比特串。
		— signedValFlag 等于1，前缀比特串是包含了单个比特值为0的比特串*/
	if (synElVal != uCoff)
	{
		//synElVal只包含一个前缀位字符串
	}
	else//synElVal == 14
	{
		int k = 0; //0阶指数哥伦布编码

		if (synElVal >= uCoff)
		{
			binVal = DecodeBypass(bs);
			//计算该读多少位
			while (binVal == 1)
			{
				synElVal += 1 << k;
				++k;
				binVal = DecodeBypass(bs);
			}

			while (k--)
			{
				binVal = DecodeBypass(bs);
				synElVal += binVal << k;
			}
		}
		//signedValFlag=0代表结果是无符号整数，所以不需要处理最后一个符号位
	}
	return synElVal;
}

int Cabac::decode_coeff_sign_flag(ParseSlice* Slice, BitStream& bs)
{
	return DecodeBypass(bs);
}

void Cabac::decode_ref_idx_lX(ParseSlice* Slice, BitStream& bs, int mbPartIdx, bool is_ref_idx_l0, uint8_t& ref_idx_lx)
{
	constexpr int ctxIdxOffset = 54;
	int ctxIdx = 0;
	int binVal = 0;
	int ctxIdxInc = Derivation_process_of_ctxIdxInc_for_the_syntax_elements_ref_idx_l0_and_ref_idx_l1(Slice, mbPartIdx, is_ref_idx_l0);

	ctxIdx = ctxIdxOffset + ctxIdxInc;
	//一元二值化
	binVal = DecodeBin(bs, false, ctxIdx);

	int synElVal = 0;
	if (binVal == 0)
	{
		synElVal = binVal;
	}
	else
	{
		ctxIdx = ctxIdxOffset + 4;
		binVal = DecodeBin(bs, false, ctxIdx);

		synElVal = 1;

		ctxIdx = ctxIdxOffset + 5;
		while (binVal == 1)
		{
			binVal = DecodeBin(bs, false, ctxIdx);
			++synElVal;
		}
	}
	ref_idx_lx = synElVal;

}

void Cabac::decode_mvd_lX(ParseSlice* Slice, BitStream& bs, int mbPartIdx, int subMbPartIdx, int mvd_flag, int& synElVal)
{
	int ctxIdxOffset = 0;
	int ctxIdxInc = 0;
	int ctxIdx = 0;
	if (mvd_flag == 0 || mvd_flag == 2)
	{
		ctxIdxOffset = 40;
	}
	else  //mvd_flag = 1,3
	{
		ctxIdxOffset = 47;
	}


	const bool is_mvd_10 = (mvd_flag == 0 || mvd_flag == 1);

	ctxIdxInc = Derivation_process_of_ctxIdxInc_for_the_syntax_elements_mvd_l0_and_mvd_l1(Slice, mbPartIdx, subMbPartIdx, ctxIdxOffset, is_mvd_10);

	//UEG3
	//-----1. 先解码前缀(TU)--------
	ctxIdx = ctxIdxOffset + ctxIdxInc;
	int binVal = 0;
	binVal = DecodeBin(bs, false, ctxIdx);

	//cMax = uCoff
	constexpr int uCoff = 9;

	//signedValFlag等于1，前缀位串等于由值为0的单个位组成的位串。  
	if (binVal == 0) //signedValFlag=1
	{
		synElVal = 0;
	}
	else
	{
		synElVal = 1;

		ctxIdx = ctxIdxOffset + 3;

		////Min( uCoff, Abs( synElVal ) )
		while (binVal == 1 && synElVal < uCoff)
		{
			binVal = DecodeBin(bs, false, ctxIdx);
			if (binVal == 0)
			{
				break;
			}

			synElVal++;

			if (synElVal <= 4)
			{
				ctxIdx++;
			}
		}

		int k = 3;//3阶指数哥伦布编码

		if (synElVal >= uCoff) //if ( Abs( synElVal ) >= uCoff ) //uCoff=9
		{
			binVal = DecodeBypass(bs);

			while (binVal == 1)
			{
				synElVal += 1 << k;
				++k;
				binVal = DecodeBypass(bs);
			}

			while (k--)
			{
				binVal = DecodeBypass(bs);

				synElVal += binVal << k;
			}
		}


		if (synElVal != 0) //if ( signedValFlag && synElVal ! = 0) //signedValFlag=1代表结果是有符号整数
		{
			binVal = DecodeBypass(bs);

			if (binVal == 1)
			{
				synElVal = -synElVal; //结果为负数
			}
		}

	}

}

int Cabac::residual_block_cabac(
	BitStream& bs, ParseSlice* Slice, int* coeffLevel, int startIdx, int endIdx,
	uint32_t maxNumCoeff, RESIDUAL_LEVEL residualLevel, int& TotalCoeff, int BlkIdx, int iCbCr
)
{
	int numDecodAbsLevelEq1 = 0;
	int numDecodAbsLevelGt1 = 0;
	memset(coeffLevel, 0, sizeof(uint32_t) * maxNumCoeff);

	int significant_coeff_flag[64] = { 0 };
	int last_significant_coeff_flag[64] = { 0 };
	int coeff_abs_level_minus1[64] = { 0 };
	int coeff_sign_flag[64] = { 0 };
	//是指块中是否包含非零变换系数幅值 
	// =0 则块中不包含非零变换系数幅值
	// =1 至少包含一个非零变换系数幅值。
	//当coded_block_flag不存在时，它将被推断为等于1。
	bool coded_block_flag = true;
	if (maxNumCoeff != 64 || Slice->sHeader.sps.ChromaArrayType == 3)
	{
		//coded_block_flag
		coded_block_flag = decode_coded_block_flag(Slice, bs, residualLevel, BlkIdx, iCbCr);
	}

	if (coded_block_flag)
	{
		int numCoeff = endIdx + 1;
		int i = startIdx;

		while (i < numCoeff - 1)
		{
			const int levelListIdx = i;
			//significant_coeff_flag[ i ]是指扫描位置i上的变换系数幅值是否非零
			//等于0，则扫描位置  i 上的变换系数幅值等于0,否则扫描位置i上的变换系数幅值不等于零
			significant_coeff_flag[i] = decode_significant_coeff_flag_and_last_significant_coeff_flag(Slice, bs, residualLevel, levelListIdx, false);

			if (significant_coeff_flag[i])
			{
				//last_significant_coeff_flag[ i ]是指对于扫描位置i，其后续的扫描位置（从 i + 1 到 maxNumCoeff – 1）上是否有非零的变换系数幅值
				//如果last_significant_coeff_flag[ i ]等于1，则块中的所有后续（按扫描顺序排序）的变换系数幅值其值均为0。
				//否则（last_significant_coeff_flag[ i ]等于0），扫描路径上有更多的非零变换系数幅值。
				last_significant_coeff_flag[i] = decode_significant_coeff_flag_and_last_significant_coeff_flag(Slice, bs, residualLevel, levelListIdx, true);

				//以下所有系数都为0
				if (last_significant_coeff_flag[i])
				{
					numCoeff = i + 1; //跳出循环，因为剩下的DCT变换系数都是0了
				}
			}
			i++;
		}

		//coeff_abs_level_minus1[i]是变换系数幅值减1的绝对值
		coeff_abs_level_minus1[numCoeff - 1] = decode_coeff_abs_level_minus1(Slice, bs, residualLevel, numDecodAbsLevelEq1, numDecodAbsLevelEq1);
		//coeff_sign_flag[ i ]是指变换系数幅值的正负符号
		//如果 coeff_sign_flag 等于0，则相应的变换系数幅值为正
		//否则（coeff_sign_flag 等于 1），相应的变换系数幅值为负
		coeff_sign_flag[numCoeff - 1] = decode_coeff_sign_flag(Slice, bs);

		coeffLevel[numCoeff - 1] = (coeff_abs_level_minus1[numCoeff - 1] + 1) * (1 - 2 * coeff_sign_flag[numCoeff - 1]);

		TotalCoeff = 1;


		//两个数值都是当前解码过程中关于同一个变换系数块的值
		if (std::abs(coeffLevel[numCoeff - 1]) == 1)
		{
			//numDecodAbsLevelEql 为绝对值等于 1 的累积解码变换系数等级
			numDecodAbsLevelEq1++;
		}
		else if (std::abs(coeffLevel[numCoeff - 1]) > 1)
		{
			//numDecodAbsLevelGt1 为绝对值 大于 1 的累积的解码变换系数等级
			numDecodAbsLevelGt1++;
		}


		for (int i = numCoeff - 2; i >= startIdx; i--)
		{
			if (significant_coeff_flag[i]) {
				//统计非0系数
				TotalCoeff++;
				coeff_abs_level_minus1[i] = decode_coeff_abs_level_minus1(Slice, bs, residualLevel, numDecodAbsLevelEq1, numDecodAbsLevelGt1);
				coeff_sign_flag[i] = decode_coeff_sign_flag(Slice, bs);

				coeffLevel[i] = (coeff_abs_level_minus1[i] + 1) * (1 - 2 * coeff_sign_flag[i]);

				if (std::abs(coeffLevel[i]) == 1)
				{
					//numDecodAbsLevelEql 为绝对值等于 1 的累积解码变换系数等级
					numDecodAbsLevelEq1++;
				}
				else if (std::abs(coeffLevel[i]) > 1)
				{
					//numDecodAbsLevelGt1 为绝对值 大于 1 的累积的解码变换系数等级
					numDecodAbsLevelGt1++;
				}
			}
		}


		//--------------将coded_block_flag值保存起来----------------------------------------
		if (residualLevel == RESIDUAL_LEVEL::Intra16x16DCLevel
			|| residualLevel == RESIDUAL_LEVEL::ChromaDCLevel
			|| residualLevel == RESIDUAL_LEVEL::CbIntra16x16DCLevel
			|| residualLevel == RESIDUAL_LEVEL::CrIntra16x16DCLevel
			) //for DC
		{
			Slice->macroblock[Slice->CurrMbAddr]->coded_block_flag_DC_pattern ^= 1 << (iCbCr + 1);//iCbCr=-1 --> luma, iCbCr=0 --> cb, iCbCr=1 --> cr
		}
		else  //for AC
		{
			Slice->macroblock[Slice->CurrMbAddr]->coded_block_flag_AC_pattern[iCbCr + 1] ^= 1 << BlkIdx; //iCbCr=-1 --> luma, iCbCr=0 --> cb, iCbCr=1 --> cr
		}
	}
	return 0;
}
int Cabac::decode_end_of_slice_flag(BitStream& bs, ParseSlice* Slice)
{
	constexpr int ctxIdxOffset = 276;
	//FL, cMax=1
	constexpr int ctxIdx = ctxIdxOffset + 0;

	return DecodeBin(bs, false, ctxIdx);
}
//语法元素mb_skip_flag的ctxIdxInc的推导过程
int Cabac::Derivation_process_of_ctxIdxInc_for_the_syntax_element_mb_skip_flag(ParseSlice* Slice)
{
	int xW = NA;
	int yW = NA;

	int mbAddrA = NA;
	Slice->getMbAddrNAndLuma4x4BlkIdxN(mbAddrA, (-1), 0, 16, 16, xW, yW);

	int mbAddrB = NA;

	Slice->getMbAddrNAndLuma4x4BlkIdxN(mbAddrB, 0, (-1), 16, 16, xW, yW);


	int condTermFlagA = 0;
	if (mbAddrA == NA || Slice->macroblock[mbAddrA]->mb_skip_flag == 1)
	{
		condTermFlagA = 0;
	}
	else
	{
		condTermFlagA = 1;
	}

	int condTermFlagB = 0;
	if (mbAddrB == NA || Slice->macroblock[mbAddrB]->mb_skip_flag == 1)
	{
		condTermFlagB = 0;
	}
	else
	{
		condTermFlagB = 1;
	}

	return condTermFlagA + condTermFlagB;
}

int Cabac::Derivation_process_of_ctxIdxInc_for_the_syntax_element_mb_type(ParseSlice* Slice, int ctxIdxOffset)
{

	int xW = NA;
	int yW = NA;

	int mbAddrA = NA;
	Slice->getMbAddrNAndLuma4x4BlkIdxN(mbAddrA, (-1), 0, 16, 16, xW, yW);

	int mbAddrB = NA;
	Slice->getMbAddrNAndLuma4x4BlkIdxN(mbAddrB, 0, (-1), 16, 16, xW, yW);


	int condTermFlagA = 0;
	if (mbAddrA == NA
		|| (ctxIdxOffset == 0 && Slice->macroblock[mbAddrA]->mbType == H264_MB_TYPE::SI)
		|| (ctxIdxOffset == 3 && Slice->macroblock[mbAddrA]->mbType == H264_MB_TYPE::I_NxN)
		|| (ctxIdxOffset == 27 && (Slice->macroblock[mbAddrA]->mbType == H264_MB_TYPE::B_Skip || Slice->macroblock[mbAddrA]->mbType == H264_MB_TYPE::B_Direct_16x16))
		)
	{
		condTermFlagA = 0;
	}
	else
	{
		condTermFlagA = 1;
	}

	int condTermFlagB = 0;
	if (mbAddrB < 0
		|| (ctxIdxOffset == 0 && Slice->macroblock[mbAddrB]->mbType == H264_MB_TYPE::SI)
		|| (ctxIdxOffset == 3 && Slice->macroblock[mbAddrB]->mbType == H264_MB_TYPE::I_NxN)
		|| (ctxIdxOffset == 27 && (Slice->macroblock[mbAddrB]->mbType == H264_MB_TYPE::B_Skip || Slice->macroblock[mbAddrB]->mbType == H264_MB_TYPE::B_Direct_16x16))
		)
	{
		condTermFlagB = 0;
	}
	else
	{
		condTermFlagB = 1;
	}

	return condTermFlagA + condTermFlagB;
}

int Cabac::Derivation_process_of_ctxIdxInc_for_the_syntax_element_transform_size_8x8_flag(ParseSlice* Slice)
{

	int xW = NA;
	int yW = NA;

	int mbAddrA = NA;
	Slice->getMbAddrNAndLuma4x4BlkIdxN(mbAddrA, (-1), 0, 16, 16, xW, yW);

	int mbAddrB = NA;

	Slice->getMbAddrNAndLuma4x4BlkIdxN(mbAddrB, 0, (-1), 16, 16, xW, yW);
	int condTermFlagA = 0;

	if (mbAddrA == NA || !Slice->macroblock[mbAddrA]->transform_size_8x8_flag)
	{
		condTermFlagA = 0;
	}
	else
	{
		condTermFlagA = 1;
	}
	int condTermFlagB = 0;

	if (mbAddrB == NA || !Slice->macroblock[mbAddrB]->transform_size_8x8_flag)
	{
		condTermFlagB = 0;
	}
	else
	{
		condTermFlagB = 1;
	}
	return condTermFlagA + condTermFlagB;
}

int Cabac::Derivation_process_of_ctxIdxInc_for_the_syntax_element_coded_block_pattern(ParseSlice* Slice, int ctxIdxOffset, int binIdx, int binVal)
{

	int xW = 0;
	int yW = 0;
	if (ctxIdxOffset == 73)
	{
		const int luma8x8BlkIdx = binIdx;

		const int xA = (luma8x8BlkIdx % 2) * 8 + (-1);
		const int yA = (luma8x8BlkIdx / 2) * 8 + (0);

		int luma8x8BlkIdxA = NA;
		int mbAddrA = NA;

		Slice->getMbAddrNAndLuma4x4BlkIdxN(mbAddrA, xA, yA, 16, 16, xW, yW);

		if (mbAddrA != NA)
		{
			luma8x8BlkIdxA = 2 * (yW / 8) + (xW / 8);
		}
		int condTermFlagA = 0;

		if (
			mbAddrA == NA
			|| Slice->macroblock[mbAddrA]->mbType == H264_MB_TYPE::I_PCM
			|| (
				Slice->CurrMbAddr != mbAddrA
				&& (Slice->macroblock[mbAddrA]->mbType != H264_MB_TYPE::P_Skip && Slice->macroblock[mbAddrA]->mbType != H264_MB_TYPE::B_Skip)
				&& ((Slice->macroblock[mbAddrA]->CodedBlockPatternLuma >> luma8x8BlkIdxA) & 1) != 0
				)
			|| (Slice->CurrMbAddr == mbAddrA && ((binVal >> luma8x8BlkIdxA) & 1) != 0)//前一个解码的coded_block_pattern的二进制值bk（k= luma8x8BlkIdxN）不等于0
			)
		{
			condTermFlagA = 0;
		}
		else
		{
			condTermFlagA = 1;
		}

		const int xB = (luma8x8BlkIdx % 2) * 8 + (0);
		const int yB = (luma8x8BlkIdx / 2) * 8 + (-1);
		int luma8x8BlkIdxB = NA;
		int mbAddrB = NA;

		Slice->getMbAddrNAndLuma4x4BlkIdxN(mbAddrB, xB, yB, 16, 16, xW, yW);

		if (mbAddrB != NA)
		{
			luma8x8BlkIdxB = 2 * (yW / 8) + (xW / 8);
		}

		int condTermFlagB = 0;

		if (
			mbAddrB == NA
			|| Slice->macroblock[mbAddrB]->mbType == H264_MB_TYPE::I_PCM
			|| (
				Slice->CurrMbAddr != mbAddrB
				&& (Slice->macroblock[mbAddrB]->mbType != H264_MB_TYPE::P_Skip && Slice->macroblock[mbAddrB]->mbType != H264_MB_TYPE::B_Skip)
				&& ((Slice->macroblock[mbAddrB]->CodedBlockPatternLuma >> luma8x8BlkIdxB) & 1) != 0
				)
			|| (Slice->CurrMbAddr == mbAddrB && ((binVal >> luma8x8BlkIdxB) & 1) != 0)//前一个解码的coded_block_pattern的二进制值bk（k= luma8x8BlkIdxN）不等于0
			)
		{
			condTermFlagB = 0;
		}
		else
		{
			condTermFlagB = 1;
		}

		return condTermFlagA + 2 * condTermFlagB;
	}
	else//ctxIdxOffset等于77
	{
		int mbAddrA = NA;
		Slice->getMbAddrNAndLuma4x4BlkIdxN(mbAddrA, (-1), 0, 16, 16, xW, yW);

		int mbAddrB = NA;
		Slice->getMbAddrNAndLuma4x4BlkIdxN(mbAddrB, 0, (-1), 16, 16, xW, yW);

		int condTermFlagA = 0;
		if (mbAddrA >= 0 && Slice->macroblock[mbAddrA]->mbType == H264_MB_TYPE::I_PCM)
		{
			condTermFlagA = 1;
		}
		else if (
			(mbAddrA == NA || Slice->macroblock[mbAddrA]->mbType == H264_MB_TYPE::P_Skip || Slice->macroblock[mbAddrA]->mbType == H264_MB_TYPE::B_Skip)
			|| (binIdx == 0 && Slice->macroblock[mbAddrA]->CodedBlockPatternChroma == 0)
			|| (binIdx == 1 && Slice->macroblock[mbAddrA]->CodedBlockPatternChroma != 2)
			)
		{
			condTermFlagA = 0;
		}
		else
		{
			condTermFlagA = 1;
		}

		int condTermFlagB = 0;
		if (mbAddrB >= 0 && Slice->macroblock[mbAddrB]->mbType == H264_MB_TYPE::I_PCM)
		{
			condTermFlagB = 1;
		}
		else if (
			(mbAddrB == NA || Slice->macroblock[mbAddrB]->mbType == H264_MB_TYPE::P_Skip || Slice->macroblock[mbAddrB]->mbType == H264_MB_TYPE::B_Skip)
			|| (binIdx == 0 && Slice->macroblock[mbAddrB]->CodedBlockPatternChroma == 0)
			|| (binIdx == 1 && Slice->macroblock[mbAddrB]->CodedBlockPatternChroma != 2)
			)
		{
			condTermFlagB = 0;
		}
		else
		{
			condTermFlagB = 1;
		}
		return condTermFlagA + 2 * condTermFlagB + ((binIdx == 1) ? 4 : 0);
	}
}

int Cabac::Derivation_process_of_ctxIdxInc_for_the_syntax_element_mb_qp_delta(ParseSlice* Slice)
{
	int ctxIdxInc = 0;
	int prevMbAddr = Slice->CurrMbAddr - 1;

	if (Slice->CurrMbAddr == Slice->sHeader.first_mb_in_slice)
	{
		prevMbAddr = -1;
	}

	if (prevMbAddr < 0
		|| Slice->macroblock[prevMbAddr]->mbType == H264_MB_TYPE::P_Skip
		|| Slice->macroblock[prevMbAddr]->mbType == H264_MB_TYPE::B_Skip
		|| Slice->macroblock[prevMbAddr]->mbType == H264_MB_TYPE::I_PCM
		|| (Slice->macroblock[prevMbAddr]->mode != H264_MB_PART_PRED_MODE::Intra_16x16 && Slice->macroblock[prevMbAddr]->CodedBlockPatternLuma == 0 && Slice->macroblock[prevMbAddr]->CodedBlockPatternChroma == 0)
		|| Slice->macroblock[prevMbAddr]->mb_qp_delta == 0
		)
	{
		ctxIdxInc = 0;
	}
	else
	{
		ctxIdxInc = 1;
	}
	return ctxIdxInc;
}

int Cabac::Derivation_process_of_ctxIdxInc_for_the_syntax_element_intra_chroma_pred_mode(ParseSlice* Slice)
{

	int xW = 0;
	int yW = 0;


	int mbAddrA = NA;
	Slice->getMbAddrNAndLuma4x4BlkIdxN(mbAddrA, (-1), 0, 16, 16, xW, yW);

	int condTermFlagA = 0;
	if (mbAddrA == NA
		|| !isInterMode(Slice->macroblock[mbAddrA]->mode)
		|| Slice->macroblock[mbAddrA]->mbType == H264_MB_TYPE::I_PCM
		|| Slice->macroblock[mbAddrA]->intra_chroma_pred_mode == 0
		)
	{
		condTermFlagA = 0;
	}
	else
	{
		condTermFlagA = 1;
	}


	int mbAddrB = NA;
	Slice->getMbAddrNAndLuma4x4BlkIdxN(mbAddrB, 0, (-1), 16, 16, xW, yW);

	int condTermFlagB = 0;
	if (mbAddrB == NA
		|| !isInterMode(Slice->macroblock[mbAddrB]->mode)
		|| Slice->macroblock[mbAddrB]->mbType == H264_MB_TYPE::I_PCM
		|| Slice->macroblock[mbAddrB]->intra_chroma_pred_mode == 0
		)
	{
		condTermFlagB = 0;
	}
	else
	{
		condTermFlagB = 1;
	}
	return condTermFlagA + condTermFlagB;
}

int Cabac::Derivation_process_of_ctxIdxInc_for_the_syntax_element_coded_block_flag(ParseSlice* Slice, int ctxBlockCat, int BlkIdx, int iCbCr)
{

	int xW = 0;
	int yW = 0;

	int mbAddrA = NA;
	int mbAddrB = NA;

	int transBlockA = NA;
	int transBlockB = NA;


	bool transBlockA_coded_block_flag = false;
	bool transBlockB_coded_block_flag = false;



	const bool isLuam = (iCbCr < 0);
	int maxW = 0;
	int maxH = 0;

	if (isLuam)
	{
		maxW = maxH = 16;
	}
	else
	{
		//色度块高度和宽度
		maxH = Slice->sHeader.sps.MbHeightC;
		maxW = Slice->sHeader.sps.MbWidthC;
	}
	if (ctxBlockCat == 0     //Intra16x16DCLevel
		|| ctxBlockCat == 6  //CbIntra16x16DCLevel
		|| ctxBlockCat == 10 //CrIntra16x16DCLevel
		)
	{

		Slice->getMbAddrNAndLuma4x4BlkIdxN(mbAddrA, (-1), 0, maxW, maxH, xW, yW);

		Slice->getMbAddrNAndLuma4x4BlkIdxN(mbAddrB, 0, (-1), maxW, maxH, xW, yW);



		if (mbAddrA != NA && Slice->macroblock[mbAddrA]->mode == H264_MB_PART_PRED_MODE::Intra_16x16)
		{
			transBlockA = 1;
			transBlockA_coded_block_flag = (Slice->macroblock[mbAddrA]->coded_block_flag_DC_pattern >> (iCbCr + 1)) & 1;
		}
		else
		{
			transBlockA = NA; //transBlockN is marked as not available.
		}



		if (mbAddrB != NA && Slice->macroblock[mbAddrB]->mode == H264_MB_PART_PRED_MODE::Intra_16x16)
		{
			transBlockB = 1;
			transBlockB_coded_block_flag = (Slice->macroblock[mbAddrB]->coded_block_flag_DC_pattern >> (iCbCr + 1)) & 1;
		}
		else
		{
			transBlockB = NA; //transBlockN is marked as not available.
		}
	}
	else if (ctxBlockCat == 1 //Intra16x16ACLevel
		|| ctxBlockCat == 2//LumaLevel4x4
		)
	{
		//位于4×4块luma4x4BlkIdx左侧和上侧的4×4亮度块的索引及其可用性状态
		int luma4x4BlkIdxA = NA;
		int luma4x4BlkIdxB = NA;


		//6.4.3 Inverse 4x4 luma block scanning process
		const int x = InverseRasterScan(BlkIdx / 4, 8, 8, 16, 0) + InverseRasterScan(BlkIdx % 4, 4, 4, 8, 0);
		const int y = InverseRasterScan(BlkIdx / 4, 8, 8, 16, 1) + InverseRasterScan(BlkIdx % 4, 4, 4, 8, 1);

		//亮度位置的差分值 表6-2（ xD, yD ）
		//当前子块距离mbAddrN左上角样点距离（ xW, yW)
		Slice->getMbAddrNAndLuma4x4BlkIdxN(mbAddrA, x + (-1), y + 0, maxW, maxH, xW, yW);

		if (mbAddrA != NA)
		{
			//左侧宏块子块索引
			luma4x4BlkIdxA = 8 * (yW / 8) + 4 * (xW / 8) + 2 * ((yW % 8) / 4) + ((xW % 8) / 4);
		}

		Slice->getMbAddrNAndLuma4x4BlkIdxN(mbAddrB, x + 0, y + (-1), maxW, maxH, xW, yW);
		if (mbAddrB != NA)
		{
			//上侧宏块子块索引
			luma4x4BlkIdxB = 8 * (yW / 8) + 4 * (xW / 8) + 2 * ((yW % 8) / 4) + ((xW % 8) / 4);
		}



		if (mbAddrA != NA
			&& Slice->macroblock[mbAddrA]->mbType != H264_MB_TYPE::P_Skip
			&& Slice->macroblock[mbAddrA]->mbType != H264_MB_TYPE::B_Skip
			&& Slice->macroblock[mbAddrA]->mbType != H264_MB_TYPE::I_PCM
			&& ((Slice->macroblock[mbAddrA]->CodedBlockPatternLuma >> (luma4x4BlkIdxA >> 2)) & 1)
			&& Slice->macroblock[mbAddrA]->transform_size_8x8_flag == false
			)
		{
			transBlockA = 1;
			transBlockA_coded_block_flag = (Slice->macroblock[mbAddrA]->coded_block_flag_AC_pattern[iCbCr + 1] >> (luma4x4BlkIdxA)) & 1;
		}
		else if (mbAddrA != NA
			&& Slice->macroblock[mbAddrA]->mbType != H264_MB_TYPE::P_Skip
			&& Slice->macroblock[mbAddrA]->mbType != H264_MB_TYPE::B_Skip
			&& ((Slice->macroblock[mbAddrA]->CodedBlockPatternLuma >> (luma4x4BlkIdxA >> 2)) & 1)
			&& Slice->macroblock[mbAddrA]->transform_size_8x8_flag
			)
		{
			transBlockA = 1;
			transBlockA_coded_block_flag = (Slice->macroblock[mbAddrA]->coded_block_flag_AC_pattern[iCbCr + 1] >> (luma4x4BlkIdxA >> 2)) & 1;
		}
		else
		{
			transBlockA = NA; //transBlockN is marked as not available.
		}



		if (mbAddrB != NA
			&& Slice->macroblock[mbAddrB]->mbType != H264_MB_TYPE::P_Skip
			&& Slice->macroblock[mbAddrB]->mbType != H264_MB_TYPE::B_Skip
			&& Slice->macroblock[mbAddrB]->mbType != H264_MB_TYPE::I_PCM
			&& ((Slice->macroblock[mbAddrB]->CodedBlockPatternLuma >> (luma4x4BlkIdxB >> 2)) & 1)
			&& Slice->macroblock[mbAddrB]->transform_size_8x8_flag == false
			)
		{
			transBlockB = 1;
			transBlockB_coded_block_flag = (Slice->macroblock[mbAddrB]->coded_block_flag_AC_pattern[iCbCr + 1] >> (luma4x4BlkIdxB)) & 1;
		}
		else if (mbAddrB != NA
			&& Slice->macroblock[mbAddrB]->mbType != H264_MB_TYPE::P_Skip
			&& Slice->macroblock[mbAddrB]->mbType != H264_MB_TYPE::B_Skip
			&& ((Slice->macroblock[mbAddrB]->CodedBlockPatternLuma >> (luma4x4BlkIdxB >> 2)) & 1)
			&& Slice->macroblock[mbAddrB]->transform_size_8x8_flag
			)
		{
			transBlockB = 1;
			transBlockB_coded_block_flag = (Slice->macroblock[mbAddrB]->coded_block_flag_AC_pattern[iCbCr + 1] >> (luma4x4BlkIdxB >> 2)) & 1;
		}
		else
		{
			transBlockB = NA; //transBlockN is marked as not available.
		}

	}
	else if (ctxBlockCat == 3) //ChromaDCLevel
	{
		Slice->getMbAddrNAndLuma4x4BlkIdxN(mbAddrA, (-1), 0, maxW, maxH, xW, yW);

		Slice->getMbAddrNAndLuma4x4BlkIdxN(mbAddrB, 0, (-1), maxW, maxH, xW, yW);

		if (mbAddrA != NA
			&& Slice->macroblock[mbAddrA]->mbType != H264_MB_TYPE::P_Skip
			&& Slice->macroblock[mbAddrA]->mbType != H264_MB_TYPE::B_Skip
			&& Slice->macroblock[mbAddrA]->mbType != H264_MB_TYPE::I_PCM
			&& Slice->macroblock[mbAddrA]->CodedBlockPatternChroma != 0)
		{
			transBlockA = 1;
			transBlockA_coded_block_flag = (Slice->macroblock[mbAddrA]->coded_block_flag_DC_pattern >> (iCbCr + 1)) & 1;
		}
		else
		{
			transBlockA = NA; //transBlockN is marked as not available.
		}



		if (mbAddrB != NA
			&& Slice->macroblock[mbAddrB]->mbType != H264_MB_TYPE::P_Skip
			&& Slice->macroblock[mbAddrB]->mbType != H264_MB_TYPE::B_Skip
			&& Slice->macroblock[mbAddrB]->mbType != H264_MB_TYPE::I_PCM
			&& Slice->macroblock[mbAddrB]->CodedBlockPatternChroma != 0)
		{
			transBlockB = 1;
			transBlockB_coded_block_flag = (Slice->macroblock[mbAddrB]->coded_block_flag_DC_pattern >> (iCbCr + 1)) & 1;
		}
		else
		{
			transBlockB = NA; //transBlockN is marked as not available.
		}
	}
	else if (ctxBlockCat == 4) //ChromaACLevel
	{

		int chroma4x4BlkIdxA = NA;
		int chroma4x4BlkIdxB = NA;

		//6.4.7 Inverse 4x4 chroma block scanning process
		const int x = InverseRasterScan(BlkIdx, 4, 4, 8, 0);
		const int y = InverseRasterScan(BlkIdx, 4, 4, 8, 1);


		//亮度位置的差分值 表6-2（ xD, yD ）
		//当前子块距离mbAddrN左上角样点距离（ xW, yW)
		Slice->getMbAddrNAndLuma4x4BlkIdxN(mbAddrA, x + (-1), y + 0, maxW, maxH, xW, yW);
		if (mbAddrA != NA)
		{
			//左侧宏块子块索引
			chroma4x4BlkIdxA = 2 * (yW / 4) + (xW / 4);
		}

		Slice->getMbAddrNAndLuma4x4BlkIdxN(mbAddrB, x + 0, y + (-1), maxW, maxH, xW, yW);
		if (mbAddrB != NA)
		{
			//上侧宏块子块索引
			chroma4x4BlkIdxB = 2 * (yW / 4) + (xW / 4);
		}


		if (mbAddrA != NA
			&& Slice->macroblock[mbAddrA]->mbType != H264_MB_TYPE::P_Skip
			&& Slice->macroblock[mbAddrA]->mbType != H264_MB_TYPE::B_Skip
			&& Slice->macroblock[mbAddrA]->mbType != H264_MB_TYPE::I_PCM
			&& Slice->macroblock[mbAddrA]->CodedBlockPatternChroma == 2
			)
		{
			transBlockA = 1;
			transBlockA_coded_block_flag = (Slice->macroblock[mbAddrA]->coded_block_flag_AC_pattern[iCbCr + 1] >> (chroma4x4BlkIdxA)) & 1;
		}
		else
		{
			transBlockA = NA; //transBlockN is marked as not available.
		}


		if (mbAddrB != NA
			&& Slice->macroblock[mbAddrB]->mbType != H264_MB_TYPE::P_Skip
			&& Slice->macroblock[mbAddrB]->mbType != H264_MB_TYPE::B_Skip
			&& Slice->macroblock[mbAddrB]->mbType != H264_MB_TYPE::I_PCM
			&& Slice->macroblock[mbAddrB]->CodedBlockPatternChroma == 2
			)
		{
			transBlockB = 1;
			transBlockB_coded_block_flag = (Slice->macroblock[mbAddrB]->coded_block_flag_AC_pattern[iCbCr + 1] >> (chroma4x4BlkIdxB)) & 1;
		}
		else
		{
			transBlockB = NA; //transBlockN is marked as not available.
		}
	}
	else if (ctxBlockCat == 5) //LumaLevel8x8
	{
		//邻近8x8亮块的推导过程
		int luma8x8BlkIdxA = 0;
		int luma8x8BlkIdxB = 0;

		const int xA = (BlkIdx % 2) * 8 - 1;
		const int yA = (BlkIdx / 2) * 8 + 0;
		Slice->getMbAddrNAndLuma4x4BlkIdxN(mbAddrA, xA, yA, maxW, maxH, xW, yW);
		if (mbAddrA != NA)
		{
			//左侧宏块子块索引
			luma8x8BlkIdxA = 2 * (yW / 8) + (xW / 8);
		}


		const int xB = (BlkIdx % 2) * 8 - 0;
		const int yB = (BlkIdx / 2) * 8 - 1;
		Slice->getMbAddrNAndLuma4x4BlkIdxN(mbAddrB, xB, yB, maxW, maxH, xW, yW);
		if (mbAddrB != NA)
		{
			//上侧宏块子块索引
			luma8x8BlkIdxB = 2 * (yW / 8) + (xW / 8);
		}

		if (mbAddrA != NA
			&& Slice->macroblock[mbAddrA]->mbType != H264_MB_TYPE::P_Skip
			&& Slice->macroblock[mbAddrA]->mbType != H264_MB_TYPE::B_Skip
			&& Slice->macroblock[mbAddrA]->mbType != H264_MB_TYPE::I_PCM
			&& ((Slice->macroblock[mbAddrA]->CodedBlockPatternLuma >> BlkIdx) & 1) != 0
			&& Slice->macroblock[mbAddrA]->transform_size_8x8_flag
			)
		{
			transBlockA = 1;
			transBlockA_coded_block_flag = (Slice->macroblock[mbAddrA]->coded_block_flag_AC_pattern[iCbCr + 1] >> (luma8x8BlkIdxA)) & 1;
		}
		else
		{
			transBlockA = NA;
		}


		if (mbAddrB != NA
			&& Slice->macroblock[mbAddrB]->mbType != H264_MB_TYPE::P_Skip
			&& Slice->macroblock[mbAddrB]->mbType != H264_MB_TYPE::B_Skip
			&& Slice->macroblock[mbAddrB]->mbType != H264_MB_TYPE::I_PCM
			&& ((Slice->macroblock[mbAddrB]->CodedBlockPatternLuma >> BlkIdx) & 1) != 0
			&& Slice->macroblock[mbAddrB]->transform_size_8x8_flag
			)
		{
			transBlockB = 1;
			transBlockB_coded_block_flag = (Slice->macroblock[mbAddrB]->coded_block_flag_AC_pattern[iCbCr + 1] >> (luma8x8BlkIdxB)) & 1;
		}
		else
		{
			transBlockB = NA;
		}

	}
	else if (ctxBlockCat == 7 //CbIntra16x16ACLevel
		|| ctxBlockCat == 8 //CbLevel4x4
		)
	{
		//相邻4x4色度块的推导过程
		int cb4x4BlkIdxA = 0;
		int cb4x4BlkIdxB = 0;
		//6.4.7 Inverse 4x4 chroma block scanning process
		const int x = InverseRasterScan(BlkIdx, 4, 4, 8, 0);
		const int y = InverseRasterScan(BlkIdx, 4, 4, 8, 1);


		//亮度位置的差分值 表6-2（ xD, yD ）
		//当前子块距离mbAddrN左上角样点距离（ xW, yW)
		Slice->getMbAddrNAndLuma4x4BlkIdxN(mbAddrA, x + (-1), y + 0, maxW, maxH, xW, yW);
		if (mbAddrA != NA)
		{
			//左侧宏块子块索引
			cb4x4BlkIdxA = 2 * (yW / 4) + (xW / 4);
		}

		Slice->getMbAddrNAndLuma4x4BlkIdxN(mbAddrB, x + 0, y + (-1), maxW, maxH, xW, yW);
		if (mbAddrB != NA)
		{
			//上侧宏块子块索引
			cb4x4BlkIdxB = 2 * (yW / 4) + (xW / 4);
		}


		if (mbAddrA != NA
			&& Slice->macroblock[mbAddrA]->mbType != H264_MB_TYPE::P_Skip
			&& Slice->macroblock[mbAddrA]->mbType != H264_MB_TYPE::B_Skip
			&& Slice->macroblock[mbAddrA]->mbType != H264_MB_TYPE::I_PCM
			&& ((Slice->macroblock[mbAddrA]->CodedBlockPatternLuma >> (cb4x4BlkIdxA >> 2)) & 1) != 0
			&& Slice->macroblock[mbAddrA]->transform_size_8x8_flag == false
			)
		{
			transBlockA = 1;
			transBlockA_coded_block_flag = (Slice->macroblock[mbAddrA]->coded_block_flag_AC_pattern[iCbCr + 1] >> (cb4x4BlkIdxA)) & 1;
		}
		else if (mbAddrA != NA
			&& Slice->macroblock[mbAddrA]->mbType != H264_MB_TYPE::P_Skip
			&& Slice->macroblock[mbAddrA]->mbType != H264_MB_TYPE::B_Skip
			&& ((Slice->macroblock[mbAddrA]->CodedBlockPatternLuma >> (cb4x4BlkIdxA >> 2)) & 1) != 0
			&& Slice->macroblock[mbAddrA]->transform_size_8x8_flag)
		{
			transBlockA = 1;
			transBlockA_coded_block_flag = (Slice->macroblock[mbAddrA]->coded_block_flag_AC_pattern[iCbCr + 1] >> (cb4x4BlkIdxA >> 2)) & 1;
		}
		else
		{
			transBlockA = NA; //transBlockN is marked as not available.
		}



		if (mbAddrB != NA
			&& Slice->macroblock[mbAddrB]->mbType != H264_MB_TYPE::P_Skip
			&& Slice->macroblock[mbAddrB]->mbType != H264_MB_TYPE::B_Skip
			&& Slice->macroblock[mbAddrB]->mbType != H264_MB_TYPE::I_PCM
			&& ((Slice->macroblock[mbAddrB]->CodedBlockPatternLuma >> (cb4x4BlkIdxB >> 2)) & 1) != 0
			&& Slice->macroblock[mbAddrB]->transform_size_8x8_flag == false
			)
		{
			transBlockB = 1;
			transBlockA_coded_block_flag = (Slice->macroblock[mbAddrB]->coded_block_flag_AC_pattern[iCbCr + 1] >> (cb4x4BlkIdxB)) & 1;
		}
		else if (mbAddrB != NA
			&& Slice->macroblock[mbAddrB]->mbType != H264_MB_TYPE::P_Skip
			&& Slice->macroblock[mbAddrB]->mbType != H264_MB_TYPE::B_Skip
			&& ((Slice->macroblock[mbAddrB]->CodedBlockPatternLuma >> (cb4x4BlkIdxB >> 2)) & 1) != 0
			&& Slice->macroblock[mbAddrB]->transform_size_8x8_flag)
		{
			transBlockB = 1;
			transBlockA_coded_block_flag = (Slice->macroblock[mbAddrB]->coded_block_flag_AC_pattern[iCbCr + 1] >> (cb4x4BlkIdxB >> 2)) & 1;
		}
		else
		{
			transBlockB = NA; //transBlockN is marked as not available.
		}

	}
	else if (ctxBlockCat == 9) //CbLevel8x8
	{
		//对于ChromaArrayType等于3的邻近8x8色度块的推导过程

		const int xA = (BlkIdx % 2) * 8 + (-1);
		const int yA = (BlkIdx / 2) * 8 + (0);

		int cb8x8BlkIdxA = NA;
		int mbAddrA = NA;

		Slice->getMbAddrNAndLuma4x4BlkIdxN(mbAddrA, xA, yA, maxW, maxH, xW, yW);

		if (mbAddrA != NA)
		{
			cb8x8BlkIdxA = 2 * (yW / 8) + (xW / 8);
		}

		const int xB = (BlkIdx % 2) * 8 + (0);
		const int yB = (BlkIdx / 2) * 8 + (-1);
		int cb8x8BlkIdxB = NA;
		int mbAddrB = NA;

		Slice->getMbAddrNAndLuma4x4BlkIdxN(mbAddrB, xB, yB, maxW, maxH, xW, yW);

		if (mbAddrB != NA)
		{
			cb8x8BlkIdxB = 2 * (yW / 8) + (xW / 8);
		}



		if (mbAddrA != NA
			&& Slice->macroblock[mbAddrA]->mbType != H264_MB_TYPE::P_Skip
			&& Slice->macroblock[mbAddrA]->mbType != H264_MB_TYPE::B_Skip
			&& Slice->macroblock[mbAddrA]->mbType != H264_MB_TYPE::I_PCM
			&& ((Slice->macroblock[mbAddrA]->CodedBlockPatternLuma >> BlkIdx) & 1) != 0
			&& Slice->macroblock[mbAddrA]->transform_size_8x8_flag
			)
		{
			transBlockA = 1;
			transBlockA_coded_block_flag = (Slice->macroblock[mbAddrA]->coded_block_flag_AC_pattern[iCbCr + 1] >> (cb8x8BlkIdxA)) & 1;
		}
		else
		{
			transBlockA = NA;
		}


		if (mbAddrB != NA
			&& Slice->macroblock[mbAddrB]->mbType != H264_MB_TYPE::P_Skip
			&& Slice->macroblock[mbAddrB]->mbType != H264_MB_TYPE::B_Skip
			&& Slice->macroblock[mbAddrB]->mbType != H264_MB_TYPE::I_PCM
			&& ((Slice->macroblock[mbAddrB]->CodedBlockPatternLuma >> BlkIdx) & 1) != 0
			&& Slice->macroblock[mbAddrB]->transform_size_8x8_flag
			)
		{
			transBlockB = 1;
			transBlockB_coded_block_flag = (Slice->macroblock[mbAddrB]->coded_block_flag_AC_pattern[iCbCr + 1] >> (cb8x8BlkIdxB)) & 1;
		}
		else
		{
			transBlockB = NA;
		}
	}
	else if (ctxBlockCat == 11 //CrIntra16x16ACLevel
		|| ctxBlockCat == 12 //CrLevel4x4
		)
	{
		//相邻4x4色度块的推导过程
		int cr4x4BlkIdxA = 0;
		int cr4x4BlkIdxB = 0;
		//6.4.7 Inverse 4x4 chroma block scanning process
		const int x = InverseRasterScan(BlkIdx, 4, 4, 8, 0);
		const int y = InverseRasterScan(BlkIdx, 4, 4, 8, 1);


		//亮度位置的差分值 表6-2（ xD, yD ）
		//当前子块距离mbAddrN左上角样点距离（ xW, yW)
		Slice->getMbAddrNAndLuma4x4BlkIdxN(mbAddrA, x + (-1), y + 0, maxW, maxH, xW, yW);
		if (mbAddrA != NA)
		{
			//左侧宏块子块索引
			cr4x4BlkIdxA = 2 * (yW / 4) + (xW / 4);
		}

		Slice->getMbAddrNAndLuma4x4BlkIdxN(mbAddrB, x + 0, y + (-1), maxW, maxH, xW, yW);
		if (mbAddrB != NA)
		{
			//上侧宏块子块索引
			cr4x4BlkIdxB = 2 * (yW / 4) + (xW / 4);
		}


		if (mbAddrA != NA
			&& Slice->macroblock[mbAddrA]->mbType != H264_MB_TYPE::P_Skip
			&& Slice->macroblock[mbAddrA]->mbType != H264_MB_TYPE::B_Skip
			&& Slice->macroblock[mbAddrA]->mbType != H264_MB_TYPE::I_PCM
			&& ((Slice->macroblock[mbAddrA]->CodedBlockPatternLuma >> (cr4x4BlkIdxA >> 2)) & 1) != 0
			&& Slice->macroblock[mbAddrA]->transform_size_8x8_flag == false
			)
		{
			transBlockA = 1;
			transBlockA_coded_block_flag = (Slice->macroblock[mbAddrA]->coded_block_flag_AC_pattern[iCbCr + 1] >> (cr4x4BlkIdxA)) & 1;
		}
		else if (mbAddrA != NA
			&& Slice->macroblock[mbAddrA]->mbType != H264_MB_TYPE::P_Skip
			&& Slice->macroblock[mbAddrA]->mbType != H264_MB_TYPE::B_Skip
			&& ((Slice->macroblock[mbAddrA]->CodedBlockPatternLuma >> (cr4x4BlkIdxA >> 2)) & 1) != 0
			&& Slice->macroblock[mbAddrA]->transform_size_8x8_flag
			)
		{
			transBlockA = 1;
			transBlockA_coded_block_flag = (Slice->macroblock[mbAddrA]->coded_block_flag_AC_pattern[iCbCr + 1] >> (cr4x4BlkIdxA >> 2)) & 1;
		}
		else
		{
			transBlockA = NA;
		}



		if (mbAddrB != NA
			&& Slice->macroblock[mbAddrB]->mbType != H264_MB_TYPE::P_Skip
			&& Slice->macroblock[mbAddrB]->mbType != H264_MB_TYPE::B_Skip
			&& Slice->macroblock[mbAddrB]->mbType != H264_MB_TYPE::I_PCM
			&& ((Slice->macroblock[mbAddrB]->CodedBlockPatternLuma >> (cr4x4BlkIdxB >> 2)) & 1) != 0
			&& Slice->macroblock[mbAddrB]->transform_size_8x8_flag == false
			)
		{
			transBlockB = 1;
			transBlockB_coded_block_flag = (Slice->macroblock[mbAddrB]->coded_block_flag_AC_pattern[iCbCr + 1] >> (cr4x4BlkIdxB)) & 1;
		}
		else if (mbAddrA != NA
			&& Slice->macroblock[mbAddrB]->mbType != H264_MB_TYPE::P_Skip
			&& Slice->macroblock[mbAddrB]->mbType != H264_MB_TYPE::B_Skip
			&& ((Slice->macroblock[mbAddrB]->CodedBlockPatternLuma >> (cr4x4BlkIdxB >> 2)) & 1) != 0
			&& Slice->macroblock[mbAddrB]->transform_size_8x8_flag
			)
		{
			transBlockB = 1;
			transBlockB_coded_block_flag = (Slice->macroblock[mbAddrB]->coded_block_flag_AC_pattern[iCbCr + 1] >> (cr4x4BlkIdxB >> 2)) & 1;
		}
		else
		{
			transBlockB = NA;
		}
	}
	else//if (ctxBlockCat == 13) //CrLevel8x8
	{
		//对于ChromaArrayType等于3的邻近8x8色度块的推导过程

		const int xA = (BlkIdx % 2) * 8 + (-1);
		const int yA = (BlkIdx / 2) * 8 + (0);

		int cr8x8BlkIdxA = NA;
		int mbAddrA = NA;

		Slice->getMbAddrNAndLuma4x4BlkIdxN(mbAddrA, xA, yA, maxW, maxH, xW, yW);

		if (mbAddrA != NA)
		{
			cr8x8BlkIdxA = 2 * (yW / 8) + (xW / 8);
		}

		const int xB = (BlkIdx % 2) * 8 + (0);
		const int yB = (BlkIdx / 2) * 8 + (-1);
		int cr8x8BlkIdxB = NA;
		int mbAddrB = NA;

		Slice->getMbAddrNAndLuma4x4BlkIdxN(mbAddrB, xB, yB, maxW, maxH, xW, yW);

		if (mbAddrB != NA)
		{
			cr8x8BlkIdxB = 2 * (yW / 8) + (xW / 8);
		}



		if (mbAddrA != NA
			&& Slice->macroblock[mbAddrA]->mbType != H264_MB_TYPE::P_Skip
			&& Slice->macroblock[mbAddrA]->mbType != H264_MB_TYPE::B_Skip
			&& Slice->macroblock[mbAddrA]->mbType != H264_MB_TYPE::I_PCM
			&& ((Slice->macroblock[mbAddrA]->CodedBlockPatternLuma >> BlkIdx) & 1) != 0
			&& Slice->macroblock[mbAddrA]->transform_size_8x8_flag
			)
		{
			transBlockA = 1;
			transBlockA_coded_block_flag = (Slice->macroblock[mbAddrA]->coded_block_flag_AC_pattern[iCbCr + 1] >> (cr8x8BlkIdxA)) & 1;
		}
		else
		{
			transBlockA = NA; //transBlockN is marked as not available.
		}


		if (mbAddrB != NA
			&& Slice->macroblock[mbAddrB]->mbType != H264_MB_TYPE::P_Skip
			&& Slice->macroblock[mbAddrB]->mbType != H264_MB_TYPE::B_Skip
			&& Slice->macroblock[mbAddrB]->mbType != H264_MB_TYPE::I_PCM
			&& ((Slice->macroblock[mbAddrB]->CodedBlockPatternLuma >> BlkIdx) & 1) != 0
			&& Slice->macroblock[mbAddrB]->transform_size_8x8_flag
			)
		{
			transBlockB = 1;
			transBlockB_coded_block_flag = (Slice->macroblock[mbAddrB]->coded_block_flag_AC_pattern[iCbCr + 1] >> (cr8x8BlkIdxB)) & 1;
		}
		else
		{
			transBlockB = NA; //transBlockN is marked as not available.
		}
	}

	int condTermFlagA = 0;
	int condTermFlagB = 0;
	if ((mbAddrA == NA && !isInterMode(Slice->macroblock[Slice->CurrMbAddr]->mode))
		|| (mbAddrA != NA && transBlockA == NA && Slice->macroblock[mbAddrA]->mbType != H264_MB_TYPE::I_PCM)
		|| (isInterMode(Slice->macroblock[Slice->CurrMbAddr]->mode)
			&& Slice->sHeader.pps.constrained_intra_pred_flag
			&& mbAddrA != NA && !isInterMode(Slice->macroblock[mbAddrA]->mode)
			&& (Slice->sHeader.nalu.nal_unit_type >= 2 && Slice->sHeader.nalu.nal_unit_type <= 4)
			)
		)
	{
		condTermFlagA = 0;
	}
	else if ((mbAddrA == NA && isInterMode(Slice->macroblock[Slice->CurrMbAddr]->mode)) || Slice->macroblock[mbAddrA]->mbType == H264_MB_TYPE::I_PCM)
	{
		condTermFlagA = 1;
	}
	else
	{
		condTermFlagA = transBlockA_coded_block_flag;
	}


	if ((mbAddrB == NA && !isInterMode(Slice->macroblock[Slice->CurrMbAddr]->mode))
		|| (mbAddrB != NA && transBlockB == NA && Slice->macroblock[mbAddrB]->mbType != H264_MB_TYPE::I_PCM)
		|| (isInterMode(Slice->macroblock[Slice->CurrMbAddr]->mode)
			&& Slice->sHeader.pps.constrained_intra_pred_flag
			&& mbAddrB != NA && !isInterMode(Slice->macroblock[mbAddrB]->mode)
			&& (Slice->sHeader.nalu.nal_unit_type >= 2 && Slice->sHeader.nalu.nal_unit_type <= 4)
			)
		)
	{
		condTermFlagB = 0;
	}
	else if ((mbAddrB == NA && isInterMode(Slice->macroblock[Slice->CurrMbAddr]->mode)) || Slice->macroblock[mbAddrB]->mbType == H264_MB_TYPE::I_PCM)
	{
		condTermFlagB = 1;
	}
	else
	{
		condTermFlagB = transBlockB_coded_block_flag;
	}

	//------ctxIdxInc( ctxBlockCat )--------------
	return condTermFlagA + 2 * condTermFlagB;
}

int Cabac::Derivation_process_of_ctxIdxInc_for_the_syntax_elements_ref_idx_l0_and_ref_idx_l1(ParseSlice* Slice, int mbPartIdx, bool is_ref_idx_l0)
{
	constexpr int subMbPartIdx = 0;

	Macroblock* mb = Slice->macroblock[Slice->CurrMbAddr];
	H264_MB_TYPE currSubMbType = mb->subMbType[mbPartIdx];
	int MbPartWidth = mb->MbPartWidth;
	int MbPartHeight = mb->MbPartHeight;

	int SubMbPartWidth = mb->SubMbPartWidth[mbPartIdx];
	int SubMbPartHeight = mb->SubMbPartHeight[mbPartIdx];

	//宏块分割  mbPartIdx 的左上角亮度样点与所处宏块左上角样点的相对位置
	int x = InverseRasterScan(mbPartIdx, MbPartWidth, MbPartHeight, 16, 0);
	int y = InverseRasterScan(mbPartIdx, MbPartWidth, MbPartHeight, 16, 1);

	//宏块分割中左上角的亮度样点位置
	int xS = 0;
	int yS = 0;
	if (mb->mbType == H264_MB_TYPE::P_8x8 || mb->mbType == H264_MB_TYPE::P_8x8ref0 || mb->mbType == H264_MB_TYPE::B_8x8)
	{

		xS = InverseRasterScan(subMbPartIdx, SubMbPartWidth, SubMbPartHeight, 8, 0);
		yS = InverseRasterScan(subMbPartIdx, SubMbPartWidth, SubMbPartHeight, 8, 1);
	}
	else
	{
		xS = 0;
		yS = 0;
	}
	int refIdxZeroFlagA = 0;
	int refIdxZeroFlagB = 0;

	int predModeEqualFlagA = 0;
	int predModeEqualFlagB = 0;

	int mbAddrA = NA;
	int mbAddrB = NA;
	int xW = 0;
	int yW = 0;

	int mbPartIdxA = 0;
	int subMbPartIdxA = 0;

	//P_8x8ref0表示虽然宏块是按照8×8划分，但码流中不传输ref_idx等信息。对于每一个子块，其ref_idx信息默认为0
	Slice->getMbAddrNAndLuma4x4BlkIdxN(mbAddrA, x + xS + (-1), y + yS + (0), 16, 16, xW, yW);
	if (mbAddrA != NA)
	{
		ParseSlice::Derivation_process_for_macroblock_and_sub_macroblock_partition_indices(Slice->macroblock[mbAddrA], xW, yW, mbPartIdxA, subMbPartIdxA);

		if (is_ref_idx_l0)
		{
			refIdxZeroFlagA = (Slice->macroblock[mbAddrA]->ref_idx_l0[mbPartIdxA] > 0) ? 0 : 1;
		}
		else
		{
			refIdxZeroFlagA = (Slice->macroblock[mbAddrA]->ref_idx_l1[mbPartIdxA] > 0) ? 0 : 1;
		}

		if (Slice->macroblock[mbAddrA]->mbType == H264_MB_TYPE::B_Direct_16x16 || Slice->macroblock[mbAddrA]->mbType == H264_MB_TYPE::B_Skip)
		{
			predModeEqualFlagA = 0;
		}
		else if (Slice->macroblock[mbAddrA]->mbType == H264_MB_TYPE::P_8x8 || Slice->macroblock[mbAddrA]->mbType == H264_MB_TYPE::B_8x8)
		{
			H264_MB_PART_PRED_MODE SubMbPredMode = Slice->macroblock[mbAddrA]->subMode[mbPartIdxA];
			if (((is_ref_idx_l0 && SubMbPredMode != H264_MB_PART_PRED_MODE::Pred_L0) || (!is_ref_idx_l0 && SubMbPredMode != H264_MB_PART_PRED_MODE::Pred_L1)) && SubMbPredMode != H264_MB_PART_PRED_MODE::BiPred)
			{
				predModeEqualFlagA = 0;
			}
			else
			{
				predModeEqualFlagA = 1;
			}

		}
		else
		{

			H264_MB_PART_PRED_MODE mbPredMode = Macroblock::getMbPartPredMode(Slice->macroblock[mbAddrA]->fix_slice_type, Slice->macroblock[mbAddrA]->fix_mb_type, Slice->macroblock[mbAddrA]->transform_size_8x8_flag, mbPartIdxA);

			if (((is_ref_idx_l0 && mbPredMode != H264_MB_PART_PRED_MODE::Pred_L0) || (!is_ref_idx_l0 && mbPredMode != H264_MB_PART_PRED_MODE::Pred_L1)) && mbPredMode != H264_MB_PART_PRED_MODE::BiPred)
			{
				predModeEqualFlagA = 0;
			}
			else
			{
				predModeEqualFlagA = 1;
			}
		}
	}
	else
	{
		predModeEqualFlagA = 0;
	}

	int mbPartIdxB = 0;
	int subMbPartIdxB = 0;
	Slice->getMbAddrNAndLuma4x4BlkIdxN(mbAddrB, x + xS + (0), y + yS + (-1), 16, 16, xW, yW);

	if (mbAddrB != NA)
	{
		ParseSlice::Derivation_process_for_macroblock_and_sub_macroblock_partition_indices(Slice->macroblock[mbAddrB], xW, yW, mbPartIdxB, subMbPartIdxB);

		if (is_ref_idx_l0)
		{
			refIdxZeroFlagB = (Slice->macroblock[mbAddrB]->ref_idx_l0[mbPartIdxB] > 0) ? 0 : 1;
		}
		else
		{
			refIdxZeroFlagB = (Slice->macroblock[mbAddrB]->ref_idx_l1[mbPartIdxB] > 0) ? 0 : 1;
		}



		if (Slice->macroblock[mbAddrB]->mbType == H264_MB_TYPE::B_Direct_16x16 || Slice->macroblock[mbAddrB]->mbType == H264_MB_TYPE::B_Skip)
		{
			predModeEqualFlagB = 0;
		}
		else if (Slice->macroblock[mbAddrB]->mbType == H264_MB_TYPE::P_8x8 || Slice->macroblock[mbAddrB]->mbType == H264_MB_TYPE::B_8x8)
		{

			H264_MB_PART_PRED_MODE SubMbPredMode = Slice->macroblock[mbAddrB]->subMode[mbPartIdxB];
			if (((is_ref_idx_l0 && SubMbPredMode != H264_MB_PART_PRED_MODE::Pred_L0) || (!is_ref_idx_l0 && SubMbPredMode != H264_MB_PART_PRED_MODE::Pred_L1)) && SubMbPredMode != H264_MB_PART_PRED_MODE::BiPred)
			{
				predModeEqualFlagB = 0;
			}
			else
			{
				predModeEqualFlagB = 1;
			}

		}
		else
		{

			H264_MB_PART_PRED_MODE mbPredMode = Macroblock::getMbPartPredMode(Slice->macroblock[mbAddrB]->fix_slice_type, Slice->macroblock[mbAddrB]->fix_mb_type, Slice->macroblock[mbAddrB]->transform_size_8x8_flag, mbPartIdxB);

			if (((is_ref_idx_l0 && mbPredMode != H264_MB_PART_PRED_MODE::Pred_L0) || (!is_ref_idx_l0 && mbPredMode != H264_MB_PART_PRED_MODE::Pred_L1)) && mbPredMode != H264_MB_PART_PRED_MODE::BiPred)
			{
				predModeEqualFlagB = 0;
			}
			else
			{
				predModeEqualFlagB = 1;
			}
		}
	}
	else
	{
		predModeEqualFlagB = 0;
	}
	int condTermFlagA = 0;
	int condTermFlagB = 0;

	if (mbAddrA == NA
		|| (Slice->macroblock[mbAddrA]->mbType == H264_MB_TYPE::P_Skip || Slice->macroblock[mbAddrA]->mbType == H264_MB_TYPE::B_Skip)
		|| isInterMode(Slice->macroblock[mbAddrA]->mode)
		|| predModeEqualFlagA == 0
		|| refIdxZeroFlagA == 1
		)
	{
		condTermFlagA = 0;
	}
	else
	{
		condTermFlagA = 1;
	}

	if (mbAddrB == NA
		|| (Slice->macroblock[mbAddrB]->mbType == H264_MB_TYPE::P_Skip || Slice->macroblock[mbAddrB]->mbType == H264_MB_TYPE::B_Skip)
		|| isInterMode(Slice->macroblock[mbAddrB]->mode)
		|| predModeEqualFlagB == 0
		|| refIdxZeroFlagB == 1
		)
	{
		condTermFlagB = 0;
	}
	else
	{
		condTermFlagB = 1;
	}

	return condTermFlagA + 2 * condTermFlagB;
}

int Cabac::Derivation_process_of_ctxIdxInc_for_the_syntax_elements_mvd_l0_and_mvd_l1(ParseSlice* Slice, int mbPartIdx, int subMbPartIdx, int ctxIdxOffset, bool is_mvd_10)
{

	Macroblock* mb = Slice->macroblock[Slice->CurrMbAddr];
	H264_MB_TYPE currSubMbType = mb->subMbType[mbPartIdx];

	int MbPartWidth = mb->MbPartWidth;
	int MbPartHeight = mb->MbPartHeight;
	int SubMbPartWidth = mb->SubMbPartWidth[mbPartIdx];
	int SubMbPartHeight = mb->SubMbPartHeight[mbPartIdx];

	//宏块分割  mbPartIdx 的左上角亮度样点与所处宏块左上角样点的相对位置
	int x = InverseRasterScan(mbPartIdx, MbPartWidth, MbPartHeight, 16, 0);
	int y = InverseRasterScan(mbPartIdx, MbPartWidth, MbPartHeight, 16, 1);

	//宏块分割中左上角的亮度样点位置
	int xS = 0;
	int yS = 0;
	if (mb->mbType == H264_MB_TYPE::P_8x8 || mb->mbType == H264_MB_TYPE::P_8x8ref0 || mb->mbType == H264_MB_TYPE::B_8x8)
	{
		xS = InverseRasterScan(subMbPartIdx, SubMbPartWidth, SubMbPartHeight, 8, 0);
		yS = InverseRasterScan(subMbPartIdx, SubMbPartWidth, SubMbPartHeight, 8, 1);
	}
	else
	{
		xS = 0;
		yS = 0;
	}

	int predModeEqualFlagA = 0;
	int predModeEqualFlagB = 0;

	int mbAddrA = NA;
	int mbAddrB = NA;
	int xW = 0;
	int yW = 0;


	int mbPartIdxA = 0;
	int subMbPartIdxA = 0;
	Slice->getMbAddrNAndLuma4x4BlkIdxN(mbAddrA, x + xS + (-1), y + yS + (0), 16, 16, xW, yW);

	if (mbAddrA != NA)
	{
		ParseSlice::Derivation_process_for_macroblock_and_sub_macroblock_partition_indices(Slice->macroblock[mbAddrA], xW, yW, mbPartIdxA, subMbPartIdxA);

		if (Slice->macroblock[mbAddrA]->mbType == H264_MB_TYPE::B_Direct_16x16 || Slice->macroblock[mbAddrA]->mbType == H264_MB_TYPE::B_Skip)
		{
			predModeEqualFlagA = 0;
		}
		else if (Slice->macroblock[mbAddrA]->mbType == H264_MB_TYPE::P_8x8 || Slice->macroblock[mbAddrA]->mbType == H264_MB_TYPE::B_8x8)
		{

			H264_MB_PART_PRED_MODE SubMbPredMode = Slice->macroblock[mbAddrA]->subMode[mbPartIdxA];

			if (((is_mvd_10 && SubMbPredMode != H264_MB_PART_PRED_MODE::Pred_L0) || (!is_mvd_10 && SubMbPredMode != H264_MB_PART_PRED_MODE::Pred_L1)) && SubMbPredMode != H264_MB_PART_PRED_MODE::BiPred)
			{
				predModeEqualFlagA = 0;
			}
			else
			{
				predModeEqualFlagA = 1;
			}
		}
		else
		{
			H264_MB_PART_PRED_MODE mbPredMode = Macroblock::getMbPartPredMode(Slice->macroblock[mbAddrA]->fix_slice_type, Slice->macroblock[mbAddrA]->fix_mb_type, Slice->macroblock[mbAddrA]->transform_size_8x8_flag, mbPartIdxA);
			if (((is_mvd_10 && mbPredMode != H264_MB_PART_PRED_MODE::Pred_L0) || (!is_mvd_10 && mbPredMode != H264_MB_PART_PRED_MODE::Pred_L1)) && mbPredMode != H264_MB_PART_PRED_MODE::BiPred)
			{
				predModeEqualFlagA = 0;
			}
			else
			{
				predModeEqualFlagA = 1;
			}
		}
	}
	else //if (mbAddrN_A < 0)
	{
		predModeEqualFlagA = 0; //FIXME:
	}

	int mbPartIdxB = 0;
	int subMbPartIdxB = 0;
	Slice->getMbAddrNAndLuma4x4BlkIdxN(mbAddrB, x + xS + (0), y + yS + (-1), 16, 16, xW, yW);
	if (mbAddrB != NA)
	{
		ParseSlice::Derivation_process_for_macroblock_and_sub_macroblock_partition_indices(Slice->macroblock[mbAddrB], xW, yW, mbPartIdxB, subMbPartIdxB);
		if (Slice->macroblock[mbAddrB]->mbType == H264_MB_TYPE::B_Direct_16x16 || Slice->macroblock[mbAddrB]->mbType == H264_MB_TYPE::B_Skip)
		{
			predModeEqualFlagB = 0;
		}
		else if (Slice->macroblock[mbAddrB]->mbType == H264_MB_TYPE::P_8x8 || Slice->macroblock[mbAddrB]->mbType == H264_MB_TYPE::B_8x8)
		{

			H264_MB_PART_PRED_MODE SubMbPredMode = Slice->macroblock[mbAddrB]->subMode[mbPartIdxB];
			if (((is_mvd_10 && SubMbPredMode != H264_MB_PART_PRED_MODE::Pred_L0) || (!is_mvd_10 && SubMbPredMode != H264_MB_PART_PRED_MODE::Pred_L1)) && SubMbPredMode != H264_MB_PART_PRED_MODE::BiPred)
			{
				predModeEqualFlagB = 0;
			}
			else
			{
				predModeEqualFlagB = 1;
			}
		}
		else
		{
			H264_MB_PART_PRED_MODE mbPredMode = Macroblock::getMbPartPredMode(Slice->macroblock[mbAddrB]->fix_slice_type, Slice->macroblock[mbAddrB]->fix_mb_type, Slice->macroblock[mbAddrB]->transform_size_8x8_flag, mbPartIdxB);
			if (((is_mvd_10 && mbPredMode != H264_MB_PART_PRED_MODE::Pred_L0) || (!is_mvd_10 && mbPredMode != H264_MB_PART_PRED_MODE::Pred_L1)) && mbPredMode != H264_MB_PART_PRED_MODE::BiPred)
			{
				predModeEqualFlagB = 0;
			}
			else
			{
				predModeEqualFlagB = 1;
			}
		}
	}
	else //if (mbAddrN_A < 0)
	{
		predModeEqualFlagB = 0; //FIXME:
	}


	int compIdx = 0;

	if (ctxIdxOffset == 40)
	{
		compIdx = 0;
	}
	else
	{
		compIdx = 1;
	}

	int absMvdCompA = 0;
	int absMvdCompB = 0;

	if (mbAddrA == NA || (Slice->macroblock[mbAddrA]->mbType == H264_MB_TYPE::P_Skip
		|| Slice->macroblock[mbAddrA]->mbType == H264_MB_TYPE::B_Skip)
		|| isInterMode(Slice->macroblock[mbAddrA]->mode)
		|| predModeEqualFlagA == 0
		)
	{
		absMvdCompA = 0;
	}
	else
	{
		//不支持帧场自适应
		//If compIdx is equal to 1, MbaffFrameFlag is equal to 1,
		//the current macroblock is a frame macroblock, and the macroblock mbAddrN is a field macroblock,
		if (is_mvd_10)
		{
			absMvdCompA = std::abs(Slice->macroblock[mbAddrA]->mvd_l0[mbPartIdxA][subMbPartIdxA][compIdx]);
		}
		else //if (is_mvd_10 == 0)
		{
			absMvdCompA = std::abs(Slice->macroblock[mbAddrA]->mvd_l1[mbPartIdxA][subMbPartIdxA][compIdx]);
		}
	}

	if (mbAddrB == NA || (Slice->macroblock[mbAddrB]->mbType == H264_MB_TYPE::P_Skip
		|| Slice->macroblock[mbAddrB]->mbType == H264_MB_TYPE::B_Skip)
		|| isInterMode(Slice->macroblock[mbAddrB]->mode)
		|| predModeEqualFlagB == 0
		)
	{
		absMvdCompB = 0;
	}
	else
	{
		//不支持帧场自适应
		//If compIdx is equal to 1, MbaffFrameFlag is equal to 1,
		//the current macroblock is a frame macroblock, and the macroblock mbAddrN is a field macroblock,
		if (is_mvd_10)
		{
			absMvdCompB = std::abs(Slice->macroblock[mbAddrB]->mvd_l0[mbPartIdxB][subMbPartIdxB][compIdx]);
		}
		else //if (is_mvd_10 == 0)
		{
			absMvdCompB = std::abs(Slice->macroblock[mbAddrB]->mvd_l1[mbPartIdxB][subMbPartIdxB][compIdx]);
		}
	}
	int ctxIdxInc = 0;
	if ((absMvdCompA + absMvdCompB) < 3)
	{
		ctxIdxInc = 0;
	}
	else if ((absMvdCompA + absMvdCompB) > 32)
	{
		ctxIdxInc = 2;
	}
	else //if ( (absMvdCompA + absMvdCompB ) >= 3 && (absMvdCompA + absMvdCompB ) <= 32)
	{
		ctxIdxInc = 1;
	}

	return ctxIdxInc;
}

int Cabac::decode_mb_type_in_I_slices(ParseSlice* Slice, BitStream& bs, int ctxIdxOffset)
{

	//如果是I片中的intra宏块，则ctxIdxOffset = 3; 
	//如果是P/SP片中的intra宏块，则ctxIdxOffset = 17;
	//如果是B片中的intra宏块，则ctxIdxOffset = 32;

	//在表9-39中17和32对应的值是0
	int ctxIdxInc = 0;

	if (ctxIdxOffset == 3) // I slice
	{
		//0,1,2 (clause 9.3.3.1.1.3)
		ctxIdxInc = Derivation_process_of_ctxIdxInc_for_the_syntax_element_mb_type(Slice, ctxIdxOffset);
	}
	else // P/SP/B slice
	{
		ctxIdxInc = 0;
	}
	int ctxIdx = ctxIdxOffset + ctxIdxInc;
	//binIdx表示二进制下标
	int binVal = DecodeBin(bs, false, ctxIdx);//binIdx = 0;
	int synElVal = 0;
	//二值化过程
	if (binVal == 0)//0
	{
		synElVal = 0;	//I_NxN
	}
	else // 1
	{
		//ctxIdx＝276 被用于 mb_type 的 binIdx 用于指示 I_PCM 模式
		//在表9-39中binIdx = 1, I/P/SP/B 对应的值都是276
		ctxIdx = 276;
		binVal = DecodeBin(bs, false, ctxIdx);//binIdx = 1;
		if (binVal == 0)//10
		{
			//注：binIdx对应的ctxIdx是ctxIdxOffset和ctxIdxInc的和

			//在表9-39中binIdx = 2,  I片中的intra宏块对应的是3，P/SP/B中的intra宏块对应的是1
			ctxIdx = ctxIdxOffset + ((ctxIdxOffset == 3) ? 3 : 1);
			binVal = DecodeBin(bs, false, ctxIdx);//binIdx = 2;
			if (binVal == 0) // 100
			{
				//在表9-39中binIdx = 3,  I片中的intra宏块对应的是4，P/SP/B中的intra宏块对应的是2
				ctxIdx = ctxIdxOffset + ((ctxIdxOffset == 3) ? 4 : 2);
				binVal = DecodeBin(bs, false, ctxIdx);//binIdx =3;
				if (binVal == 0) // 1000
				{
					//在表9-39中binIdx = 4,I/P/SP/B按照9.3.3.1.2节推导
					//表9 - 41 －ctxIdxOffset和binIdx到ctxIdxInc的对应值
					//ctxIdxInc是通过使用先前解码的bin值(b0, b1, b2，…，bk)的一些值派生出来的，
					if (ctxIdxOffset == 3) // I slice
					{
						ctxIdx = ctxIdxOffset + 6; //(b3 != 0) ? 5: 6; b3=0;
					}
					else // P/SP/B slice   // 17和32
					{
						ctxIdx = ctxIdxOffset + 3; //(b3 != 0) ? 2: 3; b3=0;
					}


					binVal = DecodeBin(bs, false, ctxIdx); //binIdx = 4;

					if (binVal == 0)  //10000
					{
						//在表9-39中binIdx = 5,ctxIdxOffset == 3查表9 - 41   P/SP/B中的intra宏块对应的是3
						ctxIdx = ctxIdxOffset + ((ctxIdxOffset == 3) ? 7 : 3);

						binVal = DecodeBin(bs, false, ctxIdx); //binIdx = 5;

						if (binVal == 0) //100000 b
						{
							synElVal = 1; //1 (I_16x16_0_0_0)
						}
						else //if (binVal == 1) //100001 b
						{
							synElVal = 2; //2 (I_16x16_1_0_0)
						}
					}
					else  //10001
					{
						ctxIdx = ctxIdxOffset + ((ctxIdxOffset == 3) ? 7 : 3); //(b3 != 0) ? 6: 7; b3=0; //Table 9-41
						binVal = DecodeBin(bs, false, ctxIdx); //binIdx = 5;

						if (binVal == 0) //(100010)b
						{
							synElVal = 3; //3 (I_16x16_2_0_0)
						}
						else //if (binVal == 1) //(100011)b
						{
							synElVal = 4; //4 (I_16x16_3_0_0)
						}
					}
				}
				else   // 1001
				{
					if (ctxIdxOffset == 3) // I slice
					{
						ctxIdx = ctxIdxOffset + 5; //(b3 != 0) ? 5: 6; b3=1; //Table 9-41
					}
					else // P/SP/B slice
					{
						ctxIdx = ctxIdxOffset + 2; //(b3 != 0) ? 2: 3; b3=1; //Table 9-41
					}


					binVal = DecodeBin(bs, false, ctxIdx);//binIdx =4;


					if (binVal == 0) //10010
					{
						//在表9-39中binIdx = 5,查表9-41，P/SP/B中的intra宏块对应的是3
						ctxIdx = ctxIdxOffset + ((ctxIdxOffset == 3) ? 6 : 3); //(b3 != 0) ? 6: 7; b3=1; //Table 9-41
						binVal = DecodeBin(bs, false, ctxIdx);//binIdx =5;

						if (binVal == 0)//100100
						{
							ctxIdx = ctxIdxOffset + ((ctxIdxOffset == 3) ? 7 : 3);
							binVal = DecodeBin(bs, false, ctxIdx);//binIdx =6;

							if (binVal == 0) //1001000
							{
								synElVal = 5; //5 (I_16x16_0_1_0)
							}
							else //if (binVal == 1) //1001001
							{
								synElVal = 6; //6 (I_16x16_1_1_0)
							}
						}
						else //100101
						{
							ctxIdx = ctxIdxOffset + ((ctxIdxOffset == 3) ? 7 : 3);
							binVal = DecodeBin(bs, false, ctxIdx);//binIdx =6;

							if (binVal == 0) //1001010
							{
								synElVal = 7; //7 (I_16x16_2_1_0)
							}
							else //if (binVal == 1) //(1001011)b
							{
								synElVal = 8; //8 (I_16x16_3_1_0)
							}
						}
					}
					else //10011
					{
						ctxIdx = ctxIdxOffset + ((ctxIdxOffset == 3) ? 6 : 3); //(b3 != 0) ? 6: 7; b3=1; //Table 9-41
						binVal = DecodeBin(bs, false, ctxIdx);//binIdx =5;

						if (binVal == 0)//100110
						{
							ctxIdx = ctxIdxOffset + ((ctxIdxOffset == 3) ? 7 : 3);
							binVal = DecodeBin(bs, false, ctxIdx);//binIdx =6;

							if (binVal == 0) //(1001100)b
							{
								synElVal = 9; //9 (I_16x16_0_2_0)
							}
							else //if (binVal == 1) //(1001101)b
							{
								synElVal = 10; //10 (I_16x16_1_2_0)
							}
						}
						else//100111
						{
							ctxIdx = ctxIdxOffset + ((ctxIdxOffset == 3) ? 7 : 3);
							binVal = DecodeBin(bs, false, ctxIdx);//binIdx =6;
							if (binVal == 0) //(1001110)b
							{
								synElVal = 11; //11 (I_16x16_2_2_0)
							}
							else //if (binVal == 1) //(1001111)b
							{
								synElVal = 12; //12 (I_16x16_3_2_0)
							}
						}
					}
				}
			}
			else// 101
			{
				ctxIdx = ctxIdxOffset + ((ctxIdxOffset == 3) ? 4 : 2);
				binVal = DecodeBin(bs, false, ctxIdx);//binIdx =3;

				if (binVal == 0)// 1010
				{
					if (ctxIdxOffset == 3) // I slice
					{
						ctxIdx = ctxIdxOffset + 6; //(b3 != 0) ? 5: 6; b3=0; //Table 9-41
					}
					else // P/SP/B slice
					{
						ctxIdx = ctxIdxOffset + 3; //(b3 != 0) ? 2: 3; b3=0; //Table 9-41
					}


					binVal = DecodeBin(bs, false, ctxIdx); //binIdx = 4;

					if (binVal == 0) // 10100
					{
						ctxIdx = ctxIdxOffset + ((ctxIdxOffset == 3) ? 7 : 3);

						binVal = DecodeBin(bs, false, ctxIdx); //binIdx = 5;

						if (binVal == 0) //(101000)b
						{
							synElVal = 13; //13 (I_16x16_0_0_1)
						}
						else //if (binVal == 1) //(101001)b
						{
							synElVal = 14; //14 (I_16x16_1_0_1)
						}
					}
					else// 10101
					{
						ctxIdx = ctxIdxOffset + ((ctxIdxOffset == 3) ? 7 : 3);//(b3 != 0) ? 6: 7; b3=0; //Table 9-41

						binVal = DecodeBin(bs, false, ctxIdx); //binIdx = 5;

						if (binVal == 0) //(101010)b
						{
							synElVal = 15; //15 (I_16x16_2_0_1)
						}
						else //if (binVal == 1) //(101011)b
						{
							synElVal = 16; //16 (I_16x16_3_0_1)
						}
					}
				}
				else// 1011
				{
					//(b3 != 0) ? 5: 6; b3=1; //Table 9-41
					//(b3 != 0) ? 2: 3; b3=1; //Table 9-41
					ctxIdx = ctxIdxOffset + ((ctxIdxOffset == 3) ? 5 : 2);

					binVal = DecodeBin(bs, false, ctxIdx); //binIdx = 4;

					if (binVal == 0)// 10110
					{
						ctxIdx = ctxIdxOffset + ((ctxIdxOffset == 3) ? 6 : 3); //(b3 != 0) ? 6: 7; b3=1; //Table 9-41
						binVal = DecodeBin(bs, false, ctxIdx); //binIdx = 5;

						if (binVal == 0)//101100
						{
							ctxIdx = ctxIdxOffset + ((ctxIdxOffset == 3) ? 7 : 3);
							binVal = DecodeBin(bs, false, ctxIdx); //binIdx = 6;


							if (binVal == 0) //(1011000)b
							{
								synElVal = 17; //17 (I_16x16_0_1_1)
							}
							else //if (binVal == 1) //(1011001)b
							{
								synElVal = 18; //18 (I_16x16_1_1_1)
							}
						}
						else//101101
						{
							ctxIdx = ctxIdxOffset + ((ctxIdxOffset == 3) ? 7 : 3);
							binVal = DecodeBin(bs, false, ctxIdx); //binIdx = 6;

							if (binVal == 0) //(1011010)b
							{
								synElVal = 19; //19 (I_16x16_2_1_1)
							}
							else //if (binVal == 1) //(1011011)b
							{
								synElVal = 20; //20 (I_16x16_3_1_1)
							}
						}
					}
					else// 10111
					{
						ctxIdx = ctxIdxOffset + ((ctxIdxOffset == 3) ? 6 : 3); //(b3 != 0) ? 6: 7; b3=1; //Table 9-41
						binVal = DecodeBin(bs, false, ctxIdx); //binIdx = 5;

						if (binVal == 0)//101110
						{
							ctxIdx = ctxIdxOffset + ((ctxIdxOffset == 3) ? 7 : 3);
							binVal = DecodeBin(bs, false, ctxIdx); //binIdx = 6;

							if (binVal == 0) //(1011100)b
							{
								synElVal = 21; //21 (I_16x16_0_2_1)
							}
							else //if (binVal == 1) //(1011101)b
							{
								synElVal = 22; //22 (I_16x16_1_2_1)
							}
						}
						else//101111
						{
							ctxIdx = ctxIdxOffset + ((ctxIdxOffset == 3) ? 7 : 3);
							binVal = DecodeBin(bs, false, ctxIdx); //binIdx = 6;
							if (binVal == 0) //(1011110)b
							{
								synElVal = 23; //23 (I_16x16_2_2_1)
							}
							else //if (binVal == 1) //(1011111)b
							{
								synElVal = 24; //24 (I_16x16_3_2_1)
							}
						}
					}
				}
			}
		}
		else  //11
		{
			synElVal = 25; //25 (I_PCM)
		}
	}

	if (synElVal == 25) //&& value(b0,b1,...,bbinIdx) == I_PCM = 25
	{
		Initialisation_process_for_the_arithmetic_decoding_engine(bs);
	}

	return synElVal;
}

int Cabac::decode_mb_type_in_SI_slices(ParseSlice* Slice, BitStream& bs, int ctxIdxOffset)
{
	int synElVal = 0;

	int ctxIdxInc = Derivation_process_of_ctxIdxInc_for_the_syntax_element_mb_type(Slice, ctxIdxOffset);
	ctxIdxOffset = 0;
	int ctxIdx = ctxIdxOffset + ctxIdxInc;

	int binVal = DecodeBin(bs, false, ctxIdx);

	//如果是SI宏块b0=0，否则是I宏块
	if (binVal == 0)
	{
		synElVal = 0;
	}
	else
	{
		ctxIdxOffset = 3;
		synElVal = decode_mb_type_in_I_slices(Slice, bs, ctxIdxOffset);
		//SI条带里面可能包含了I宏块 1-26，所以这里+1是因为后面修正了mb_type，因为SI条带里宏块类型的值可能是1-26
		synElVal += 1;
	}
	return synElVal;
}

int Cabac::decode_mb_type_in_P_SP_slices(ParseSlice* Slice, BitStream& bs, int ctxIdxOffset)
{

	int synElVal = 0;
	//P/SP条带里的P宏块ctxIdxOffset=14，I宏块ctxIdxOffset=17
	ctxIdxOffset = 14;
	//表9-39 ctxIdxOffset=14和binIdx对应的值是ctxIdxInc=0  （ctxIdxOffset+ctxIdxInc）
	int ctxIdx = ctxIdxOffset + 0;

	int binVal = DecodeBin(bs, false, ctxIdx);//binIdx = 0;

	if (binVal == 0)  //0
	{
		ctxIdx = ctxIdxOffset + 1;
		int binVal = DecodeBin(bs, false, ctxIdx);//binIdx = 1; b1=binVal;

		if (binVal == 0)//00
		{
			//表 9-41－ctxIdxOffset和binIdx到ctxIdxInc的对应值
			ctxIdx = ctxIdxOffset + 2; //(b1 != 1) ? 2: 3; b1=0; //Table 9-41 //2,3 (clause 9.3.3.1.2)
			int binVal = DecodeBin(bs, false, ctxIdx);//binIdx = 2;
			if (binVal == 0)//000
			{
				synElVal = 0;//0 (P_L0_16x16)
			}
			else//001
			{
				synElVal = 3;//3 (P_8x8)
			}
		}
		else//01
		{
			ctxIdx = ctxIdxOffset + 3; //(b1 != 1) ? 2: 3; b1=1; //Table 9-41 //2,3 (clause 9.3.3.1.2)
			int binVal = DecodeBin(bs, false, ctxIdx);//binIdx = 2;

			if (binVal == 0) //(010)b
			{
				synElVal = 2; //2 (P_L0_L0_8x16)
			}
			else //if (binVal == 1) //(011)b
			{
				synElVal = 1; //1 (P_L0_L0_16x8)
			}
		}
	}
	else
	{
		//p/sp slice里的i宏块
		ctxIdxOffset = 17;
		synElVal = decode_mb_type_in_I_slices(Slice, bs, ctxIdxOffset);

		synElVal += 5;
	}

	return synElVal;
}

int Cabac::decode_mb_type_in_B_slices(ParseSlice* Slice, BitStream& bs, int ctxIdxOffset)
{
	int synElVal = 0;

	ctxIdxOffset = 27;

	int ctxIdxInc = Derivation_process_of_ctxIdxInc_for_the_syntax_element_mb_type(Slice, ctxIdxOffset);

	int ctxIdx = ctxIdxOffset + ctxIdxInc;
	int binVal = DecodeBin(bs, false, ctxIdx);


	if (binVal == 0)//0
	{
		synElVal = 0; //0 (B_Direct_16x16)
	}
	else//1
	{
		int ctxIdx = ctxIdxOffset + 3;

		binVal = DecodeBin(bs, false, ctxIdx);//binIdx = 1;
		if (binVal == 0) //10
		{
			int ctxIdx = ctxIdxOffset + 5; //(b1 != 0) ? 4: 5; b1=0; //Table 9-41 //2,3 (clause 9.3.3.1.2)

			binVal = DecodeBin(bs, false, ctxIdx);//binIdx = 2;

			if (binVal == 0) //100
			{
				synElVal = 1; //1 (B_L0_16x16)
			}
			else//101
			{
				synElVal = 2; //2 (B_L1_16x16)
			}

		}
		else//11
		{
			int ctxIdx = ctxIdxOffset + 4; //(b1 != 0) ? 4: 5; b1=1; //Table 9-41 //2,3 (clause 9.3.3.1.2)

			binVal = DecodeBin(bs, false, ctxIdx);//binIdx = 2;

			if (binVal == 0)//110
			{
				ctxIdx = ctxIdxOffset + 5; //Table 9-39
				binVal = DecodeBin(bs, false, ctxIdx); //binIdx = 3;

				if (binVal == 0)//1100
				{
					ctxIdx = ctxIdxOffset + 5; //Table 9-39
					binVal = DecodeBin(bs, false, ctxIdx); //binIdx = 4;
					if (binVal == 0)//11000
					{
						ctxIdx = ctxIdxOffset + 5; //Table 9-39
						binVal = DecodeBin(bs, false, ctxIdx); //binIdx = 5;

						if (binVal == 0) //(110000)b
						{
							synElVal = 3; //3 (B_Bi_16x16)
						}
						else //if (binVal == 1) //(110001)b
						{
							synElVal = 4; //4 (B_L0_L0_16x8)
						}
					}
					else//11001
					{
						ctxIdx = ctxIdxOffset + 5; //Table 9-39
						binVal = DecodeBin(bs, false, ctxIdx); //binIdx = 5;

						if (binVal == 0) //(110010)b
						{
							synElVal = 5; //5 (B_L0_L0_8x16)
						}
						else //if (binVal == 1) //(110011)b
						{
							synElVal = 6; //6 (B_L1_L1_16x8)
						}
					}
				}
				else//1101
				{
					ctxIdx = ctxIdxOffset + 5; //Table 9-39
					binVal = DecodeBin(bs, false, ctxIdx); //binIdx = 4;

					if (binVal == 0)//11010
					{
						ctxIdx = ctxIdxOffset + 5; //Table 9-39
						binVal = DecodeBin(bs, false, ctxIdx); //binIdx = 5;

						if (binVal == 0) //(110100)b
						{
							synElVal = 7; //7 (B_L1_L1_8x16)
						}
						else //if (binVal == 1) //(110101)b
						{
							synElVal = 8; //8 (B_L0_L1_16x8)
						}
					}
					else//11011
					{
						ctxIdx = ctxIdxOffset + 5; //Table 9-39
						binVal = DecodeBin(bs, false, ctxIdx); //binIdx = 5;

						if (binVal == 0) //(110110)b
						{
							synElVal = 9; //9 (B_L0_L1_8x16)
						}
						else //if (binVal == 1) //(110111)b
						{
							synElVal = 10; //10 (B_L1_L0_16x8)
						}
					}
				}
			}
			else//111
			{
				ctxIdx = ctxIdxOffset + 5; //Table 9-39
				binVal = DecodeBin(bs, false, ctxIdx); //binIdx = 3;


				if (binVal == 0)//1110
				{
					ctxIdx = ctxIdxOffset + 5; //Table 9-39
					binVal = DecodeBin(bs, false, ctxIdx); //binIdx = 4;
					if (binVal == 0)//11100
					{
						ctxIdx = ctxIdxOffset + 5; //Table 9-39
						binVal = DecodeBin(bs, false, ctxIdx); //binIdx = 5;

						if (binVal == 0)//111000
						{
							ctxIdx = ctxIdxOffset + 5; //Table 9-39
							binVal = DecodeBin(bs, false, ctxIdx); //binIdx = 6;

							if (binVal == 0) //(1110000)b
							{
								synElVal = 12; //12 (B_L0_Bi_16x8)
							}
							else //if (binVal == 1) //(1110001)b
							{
								synElVal = 13; //13 (B_L0_Bi_8x16)
							}
						}
						else//111001
						{
							ctxIdx = ctxIdxOffset + 5; //Table 9-39
							binVal = DecodeBin(bs, false, ctxIdx); //binIdx = 6;

							if (binVal == 0) //(1110010)b
							{
								synElVal = 14; //14 (B_L1_Bi_16x8)
							}
							else //if (binVal == 1) //(1110011)b
							{
								synElVal = 15; //15 (B_L1_Bi_8x16)
							}
						}
					}
					else//11101
					{
						ctxIdx = ctxIdxOffset + 5; //Table 9-39
						binVal = DecodeBin(bs, false, ctxIdx); //binIdx = 5;

						if (binVal == 0)//111010
						{
							ctxIdx = ctxIdxOffset + 5; //Table 9-39
							binVal = DecodeBin(bs, false, ctxIdx); //binIdx = 6;

							if (binVal == 0) //(1110100)b
							{
								synElVal = 16; //16 (B_Bi_L0_16x8)
							}
							else //if (binVal == 1) //(1110101)b
							{
								synElVal = 17; //17 (B_Bi_L0_8x16)
							}
						}
						else//111011
						{
							ctxIdx = ctxIdxOffset + 5; //Table 9-39
							binVal = DecodeBin(bs, false, ctxIdx); //binIdx = 6;

							if (binVal == 0) //(1110110)b
							{
								synElVal = 18; //18 (B_Bi_L1_16x8)
							}
							else //if (binVal == 1) //(1110111)b
							{
								synElVal = 19; //19 (B_Bi_L1_8x16)
							}
						}
					}
				}
				else//1111
				{
					ctxIdx = ctxIdxOffset + 5; //Table 9-39
					binVal = DecodeBin(bs, false, ctxIdx); //binIdx = 4;
					if (binVal == 0)//11110
					{
						ctxIdx = ctxIdxOffset + 5; //Table 9-39
						binVal = DecodeBin(bs, false, ctxIdx); //binIdx = 5;

						if (binVal == 0)//111100
						{
							ctxIdx = ctxIdxOffset + 5; //Table 9-39
							binVal = DecodeBin(bs, false, ctxIdx); //binIdx = 6;
							if (binVal == 0) //(1111000)b
							{
								synElVal = 20; //20 (B_Bi_Bi_16x8)
							}
							else //if (binVal == 1) //(1111001)b
							{
								synElVal = 21; //21 (B_Bi_Bi_8x16)
							}
						}
						else//111101
						{
							ctxIdxOffset = 32;
							synElVal = decode_mb_type_in_I_slices(Slice, bs, ctxIdx) + 23;
						}
					}
					else//11111
					{
						ctxIdx = ctxIdxOffset + 5; //Table 9-39
						binVal = DecodeBin(bs, false, ctxIdx); //binIdx = 5;

						if (binVal == 0) //(111110)b
						{
							synElVal = 11; //11 (B_L1_L0_8x16)
						}
						else //if (binVal == 1) //(111111)b
						{
							synElVal = 22; //22 (B_8x8)
						}
					}
				}
			}
		}
	}
	return synElVal;
}

int Cabac::decode_sub_mb_type_in_P_SP_slices(BitStream& bs)
{
	constexpr int ctxIdxOffset = 21;
	int ctxIdx = 0;
	int binVal = 0;
	ctxIdx = ctxIdxOffset + 0;//binIdx=0
	binVal = DecodeBin(bs, false, ctxIdx);

	int synElVal = 0;
	if (binVal == 1) // 1
	{
		synElVal = 0; //P_L0_8x8
	}
	else// 0
	{
		ctxIdx = ctxIdxOffset + 1;//binIdx=1
		binVal = DecodeBin(bs, false, ctxIdx);

		if (binVal == 0) //00
		{
			synElVal = 1;// P_L0_8x4
		}
		else //01
		{
			ctxIdx = ctxIdxOffset + 2;//binIdx=2
			binVal = DecodeBin(bs, false, ctxIdx);
			if (binVal == 1)//011
			{
				synElVal = 2;// P_L0_4x8
			}
			else //010
			{
				synElVal = 3;//  P_L0_4x4
			}
		}
	}
	return synElVal;
}

int Cabac::decode_sub_mb_type_in_B_slices(BitStream& bs)
{
	constexpr int ctxIdxOffset = 36;
	int ctxIdx = 0;
	int binVal = 0;
	ctxIdx = ctxIdxOffset + 0;//binIdx=0
	binVal = DecodeBin(bs, false, ctxIdx); //b0

	int synElVal = 0;
	if (binVal == 0)//0
	{
		synElVal = 0;// B_Direct_8x8
	}
	else //1
	{
		ctxIdx = ctxIdxOffset + 1;//binIdx=1
		binVal = DecodeBin(bs, false, ctxIdx);//b1
		if (binVal == 0) //10
		{
			ctxIdx = ctxIdxOffset + 3;//binIdx=2  (b1  !=  0) ? 2: 3 
			binVal = DecodeBin(bs, false, ctxIdx);//b2

			if (binVal == 0)//100
			{
				synElVal = 1;// B_L0_8x8
			}
			else//101
			{
				synElVal = 2;// B_L1_8x8
			}
		}
		else //11
		{
			ctxIdx = ctxIdxOffset + 2;//binIdx=2  (b1  !=  0) ? 2: 3 
			binVal = DecodeBin(bs, false, ctxIdx);//b2

			if (binVal == 0) // 110
			{
				ctxIdx = ctxIdxOffset + 3;//binIdx=3 
				binVal = DecodeBin(bs, false, ctxIdx);

				if (binVal == 0) // 1100
				{
					ctxIdx = ctxIdxOffset + 3;//binIdx=4
					binVal = DecodeBin(bs, false, ctxIdx);
					if (binVal == 0) // 11000
					{
						synElVal = 3;// B_Bi_8x8
					}
					else// 11001
					{
						synElVal = 4;// B_L0_8x4
					}
				}
				else// 1101
				{
					ctxIdx = ctxIdxOffset + 3;//binIdx=4 
					binVal = DecodeBin(bs, false, ctxIdx);

					if (binVal == 0)// 11010
					{
						synElVal = 5;// B_L0_4x8
					}
					else// 11011
					{
						synElVal = 6;// B_L1_8x4
					}
				}
			}
			else // 111
			{
				ctxIdx = ctxIdxOffset + 3;//binIdx=3
				binVal = DecodeBin(bs, false, ctxIdx);

				if (binVal == 0) // 1110
				{
					ctxIdx = ctxIdxOffset + 3;//binIdx=4
					binVal = DecodeBin(bs, false, ctxIdx);

					if (binVal == 0)// 11100
					{
						ctxIdx = ctxIdxOffset + 3;//binIdx=5
						binVal = DecodeBin(bs, false, ctxIdx);
						if (binVal == 0)// 111000
						{
							synElVal = 7;// B_L1_4x8
						}
						else// 111001
						{
							synElVal = 8;// B_Bi_8x4
						}
					}
					else// 11101
					{
						ctxIdx = ctxIdxOffset + 3;//binIdx=5
						binVal = DecodeBin(bs, false, ctxIdx);

						if (binVal == 0)// 111010
						{
							synElVal = 9;// B_Bi_4x8
						}
						else// 111011
						{
							synElVal = 10;// B_L0_4x4
						}
					}
				}
				else // 1111
				{
					ctxIdx = ctxIdxOffset + 3;//binIdx=4
					binVal = DecodeBin(bs, false, ctxIdx);

					if (binVal == 0) //(11110)b
					{
						synElVal = 11; // (B_L1_4x4)
					}
					else //(11111)b
					{
						synElVal = 12; // (B_Bi_4x4)
					}
				}
			}
		}

	}

	return synElVal;
}

//这个过程的输出是已解码的值binVal，以及更新的变量codIRange和codIOffset
int Cabac::DecodeBin(BitStream& bs, int bypassFlag, int ctxIdx)
{
	int binVal = 0;

	if (bypassFlag == 1)
	{
		binVal = DecodeBypass(bs);
	}
	else
	{
		if (ctxIdx == 276) //decoding of end_of_slice_flag and of the bin indicating the I_PCM
		{
			binVal = DecodeTerminate(bs);
		}
		else
		{
			//DecodeDecision(ctxIdx)
			binVal = DecodeDecision(bs, ctxIdx);
		}
	}
	return binVal;
}
//二进制判决的算术解码过程
int Cabac::DecodeDecision(BitStream& bs, int ctxIdx)
{

	const int rangeTabLPS[64][4] =
	{
		{128, 176, 208, 240},
		{128, 167, 197, 227},
		{128, 158, 187, 216},
		{123, 150, 178, 205},
		{116, 142, 169, 195},
		{111, 135, 160, 185},
		{105, 128, 152, 175},
		{100, 122, 144, 166},
		{95, 116, 137, 158},
		{90, 110, 130, 150},
		{85, 104, 123, 142},
		{81, 99, 117, 135},
		{77, 94, 111, 128},
		{73, 89, 105, 122},
		{69, 85, 100, 116},
		{66, 80, 95, 110},
		{62, 76, 90, 104},
		{59, 72, 86, 99},
		{56, 69, 81, 94},
		{53, 65, 77, 89},
		{51, 62, 73, 85},
		{48, 59, 69, 80},
		{46, 56, 66, 76},
		{43, 53, 63, 72},
		{41, 50, 59, 69},
		{39, 48, 56, 65},
		{37, 45, 54, 62},
		{35, 43, 51, 59},
		{33, 41, 48, 56},
		{32, 39, 46, 53},
		{30, 37, 43, 50},
		{29, 35, 41, 48},
		{27, 33, 39, 45},
		{26, 31, 37, 43},
		{24, 30, 35, 41},
		{23, 28, 33, 39},
		{22, 27, 32, 37},
		{21, 26, 30, 35},
		{20, 24, 29, 33},
		{19, 23, 27, 31},
		{18, 22, 26, 30},
		{17, 21, 25, 28},
		{16, 20, 23, 27},
		{15, 19, 22, 25},
		{14, 18, 21, 24},
		{14, 17, 20, 23},
		{13, 16, 19, 22},
		{12, 15, 18, 21},
		{12, 14, 17, 20},
		{11, 14, 16, 19},
		{11, 13, 15, 18},
		{10, 12, 15, 17},
		{10, 12, 14, 16},
		{9, 11, 13, 15},
		{9, 11, 12, 14},
		{8, 10, 12, 14},
		{8, 9, 11, 13},
		{7, 9, 11, 12},
		{7, 9, 10, 12},
		{7, 8, 10, 11},
		{6, 8, 9, 11},
		{6, 7, 9, 10},
		{6, 7, 8, 9},
		{2, 2, 2, 2},
	};

	const int transIdxLPS[64] =
	{
		0, 0, 1, 2, 2, 4, 4, 5, 6, 7, 8, 9, 9, 11, 11, 12,
		13, 13, 15, 15, 16, 16, 18, 18, 19, 19, 21, 21, 22, 22, 23, 24,
		24, 25, 26, 26, 27, 27, 28, 29, 29, 30, 30, 30, 31, 32, 32, 33,
		33, 33, 34, 34, 35, 35, 35, 36, 36, 36, 37, 37, 37, 38, 38, 63
	};

	const int transIdxMPS[64] =
	{
		1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,
		17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32,
		33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48,
		49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 62, 63
	};

	int binVal = 0;
	int pStateIdx = stateIdx[ctxIdx];
	int qCodIRangeIdx = (codIRange >> 6) & 3;
	int valMPS = MPSValue[ctxIdx];

	int codIRangeLPS = rangeTabLPS[pStateIdx][qCodIRangeIdx];
	codIRange = codIRange - codIRangeLPS;

	if (codIOffset >= codIRange)
	{
		binVal = !valMPS;
		codIOffset = codIOffset - codIRange;
		codIRange = codIRangeLPS;

		if (pStateIdx == 0)
		{
			MPSValue[ctxIdx] = 1 - valMPS;
		}

		stateIdx[ctxIdx] = transIdxLPS[pStateIdx]; //9.3.3.2.1.1 State transition process
	}
	else
	{
		binVal = valMPS;

		stateIdx[ctxIdx] = transIdxMPS[pStateIdx]; //9.3.3.2.1.1 State transition process
	}
	RenormD(bs);

	return binVal;
}

int Cabac::DecodeBypass(BitStream& bs)
{
	codIOffset = codIOffset << 1;
	codIOffset = codIOffset | bs.readBit();

	int binVal = 0;
	if (codIOffset >= codIRange)
	{
		binVal = 1;
		codIOffset = codIOffset - codIRange;
	}
	else
	{
		binVal = 0;
	}
	return binVal;
}

//解析终止符
int Cabac::DecodeTerminate(BitStream& bs)
{
	int binVal = 0;
	codIRange = codIRange - 2;
	if (codIOffset >= codIRange)
	{
		//不使用重归一化过程，且CABAC解码结束
		binVal = 1;
	}
	else
	{
		binVal = 0;
		//算术解码引擎的重归一化过程
		RenormD(bs);
	}
	return binVal;
}
//重归一化过程
void Cabac::RenormD(BitStream& bs)
{
	while (codIRange < 0x0100) //256
	{
		codIRange = codIRange << 1;
		codIOffset = codIOffset << 1;
		codIOffset = codIOffset | bs.readBit();
	}
}

int Cabac::getCtxBlockCat(int NumC8x8, RESIDUAL_LEVEL residualLevel)
{
	// ctxBlockCats[][1] = ctxBlockCat;
	// ctxBlockCats[][0] = maxNumCoeff;
	//NumC8x8 = 4 / ( SubWidthC * SubHeightC ) 
	int ctxBlockCats[14][2] = {
		{16, 0},
		{15, 1},
		{16, 2},
		{4 * NumC8x8, 3},
		{15, 4},
		{64, 5},
		{16, 6},
		{15, 7},
		{16, 8},
		{64, 9},
		{16, 10},
		{15, 11},
		{16, 12},
		{64, 13}
	};

	int ctxBlockCat = NA;

	switch (residualLevel)
	{
	case RESIDUAL_LEVEL::LumaLevel4x4:
		ctxBlockCat = ctxBlockCats[2][1];
		break;
	case RESIDUAL_LEVEL::LumaLevel8x8:
		ctxBlockCat = ctxBlockCats[5][1];
		break;
	case RESIDUAL_LEVEL::ChromaDCLevel:
		ctxBlockCat = ctxBlockCats[3][1];
		break;
	case RESIDUAL_LEVEL::ChromaACLevelCb:
	case RESIDUAL_LEVEL::ChromaACLevelCr:
	case RESIDUAL_LEVEL::ChromaACLevel:
		ctxBlockCat = ctxBlockCats[4][1];
		break;
	case RESIDUAL_LEVEL::Intra16x16DCLevel:
		ctxBlockCat = ctxBlockCats[0][1];
		break;
	case RESIDUAL_LEVEL::Intra16x16ACLevel:
		ctxBlockCat = ctxBlockCats[1][1];
		break;
	case RESIDUAL_LEVEL::CbIntra16x16DCLevel:
		ctxBlockCat = ctxBlockCats[6][1];
		break;
	case RESIDUAL_LEVEL::CbIntra16x16ACLevel:
		ctxBlockCat = ctxBlockCats[7][1];
		break;
	case RESIDUAL_LEVEL::CbLevel4x4:
		ctxBlockCat = ctxBlockCats[8][1];
		break;
	case RESIDUAL_LEVEL::CbLevel8x8:
		ctxBlockCat = ctxBlockCats[9][1];
		break;
	case RESIDUAL_LEVEL::CrLevel4x4:
		ctxBlockCat = ctxBlockCats[12][1];
		break;
	case RESIDUAL_LEVEL::CrLevel8x8:
		ctxBlockCat = ctxBlockCats[13][1];
		break;
	case RESIDUAL_LEVEL::CrIntra16x16DCLevel:
		ctxBlockCat = ctxBlockCats[10][1];
		break;
	case RESIDUAL_LEVEL::CrIntra16x16ACLevel:
		ctxBlockCat = ctxBlockCats[11][1];
		break;
	default:
		printError("residualLevel匹配不到");
		exit(-1);
		break;
	}
	return ctxBlockCat;
}

//上下文变量的初始化过程
void Cabac::Initialisation_process_for_context_variables(SLIECETYPE slice_type, int SliceQPY, int cabac_init_idc)
{
	//变量pStateIdx对应于概率状态索引，变量 valMPS对应于最大可能
	int m = 0;
	int n = 0;

	for (size_t ctxIdx = 0; ctxIdx < 1024; ctxIdx++)
	{
		getMN(ctxIdx, slice_type, cabac_init_idc, m, n);

		int preCtxState = Clip3(1, 126, ((m * Clip3(0, 51, SliceQPY)) >> 4) + n);
		if (preCtxState <= 63)
		{
			stateIdx[ctxIdx] = 63 - preCtxState;
			MPSValue[ctxIdx] = 0;
		}
		else
		{
			stateIdx[ctxIdx] = preCtxState - 64;
			MPSValue[ctxIdx] = 1;
		}
	}
}
//算术解码引擎的初始化过程
void Cabac::Initialisation_process_for_the_arithmetic_decoding_engine(BitStream& bs)
{
	codIRange = 0x01FE; //510 = 0x01FE

	codIOffset = bs.readMultiBit(9); //read_bits(9);
}


